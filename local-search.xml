<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><p>MySQL是关系型数据库的一种，另外还有非关系型数据库</p></li><li><p>命令行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 密码 --注意区分p的大小写，大小写p分别表示端口和密码&lt;br&#x2F;&gt;</span><br><span class="line">update mysql.user set authentication_string&#x3D;password(&#39;密码&#39;)where user&#x3D;&#39;root&#39; and Host&#x3D;&#39;Localhost&#39;;--修改用户密码</span><br><span class="line">flush privileges; --刷新权限</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">show databases; -- 查看所有的数据库</span><br><span class="line"></span><br><span class="line">exit；</span><br></pre></td></tr></table></figure><p>PS: 敲完代码敲回车，在第二行输入<code>;</code>再敲回车命令结果就会回显，或者直接语句后面加<code>;</code>再敲回车同样会回显<br>PS: 剩下的懒得写了，命令行语句百度查询</p></li><li><p>MySQL语句：中括号代表可选操作</p><blockquote><p><code>CREATE DATABASE [IF NOT EXISTS] yuexinbaiwan      --创建数据库</code><br><code>DROP DATABASE IF EXISTS yuexinbaiwan      --删除数据库</code></p></blockquote></li><li><p>MySQL引擎：InnoDB和MyISAM</p></li><li><p>修改表名：<code>ALTER TABLE 原表名 RENAME AS 目标表名</code><br>修改约束：<code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(11)</code><br>修改字段名：<code>ALTER TABLE 表名 CHANGE 原字段名 目标字段名 INT(1)</code><br>增加表字段：<code>ALTER TABLE 表名 ADD 字段名 INT(11)</code><br>删除表字段：<code>ALTER TABLE 表名 DROP 字段名</code><br>删除表：<code>DROP TABLE IF EXISTS 表名</code><br>注：大小写不敏感</p></li><li><p>外键：企业为了简化开发和测试，一般会避免使用外键和级联</p></li><li><p>修改具体数据：<code>UPDATA 表名 SET 字段名=&quot;...&quot; where 约束条件</code>(修改数据必须加约束条件，不然会默认修改该字段所有数据)<br><code>PS：使用时再查找相关文档细化知识</code></p></li><li><p>删除具体数据：<code>DELETE FROM 表名 [where 约束条件]</code><br>清空表：<code>TRUNCATE 表名</code></p></li></ol><ul><li><code>DELETE</code>和<code>TRUNCATE</code>的异同点：两者都删除数据，但不会删除表结构，不同的是使用<code>TRUNCATE</code>不影响事物，且重新设置自增列，计数器归零<br>而<code>DELETE</code>不会影响自增量</li><li>补充： 自增量在InnoDB中是存在内存中，断电即失；而在MyISAM则继续从上一个自增量开始，存在文件中，不会断电即失</li></ul><ol start="9"><li>查询+别名：<code>SELECT 字段名 AS 别名,字段名 AS 别名  FROM  表名</code>(表名也可以加别名)<br>查询+拼接：<code>SELECT CONTACT(&#39;需要拼接的数据&#39;,字段名) AS 别名 FROM 表名</code><br>查询+去重：<code>SELECT DISTINCT 字段名 FROM 表名</code><br><code>PS：还有许多，具体查阅文档</code></li><li>MySQL运算符：算术运算符，比较运算符，逻辑运算符，位运算符</li><li>在模糊查询中注意<code>%</code>和<code>_</code>的区别</li><li>联表查询的七种join理论： <img src="/img/join.jpg" alt="avatar"></li><li>自连接+联表查询</li><li>查询结果排序：<code>ORDER BY [ASC|DSC]</code>(升序|降序)</li><li>查询结果分页：<code>LIMIT 6,5 //检索记录7-11行</code>或者<code>LIMIT 5 //检索记录前5行，相当于LIMIT 0,5</code>,<br>即<code>LIMIT 起始值 [,检索数目]</code>(LIMIT中计数默认从0开始；即第0行，第1行)</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/2020/02/27/Spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/27/Spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>Spring是非入侵式框架，基于Interface21框架；IOC+AOP+事物处理</li><li>控制反转(IOC)：对象的创建与对象间的依赖关系完全硬编码在程序中并由程序自己控制，而控制反转则将控制权转移给第三方； 可以利用依赖注入(DI)实现</li><li>有XML和注解两种实现IOC</li><li>XML：</li></ol><ul><li>使用Spring来创建对象，在Spring中都称为bean</li><li>在bean中来实现对象的属性赋值</li><li>这种情况下，程序不用new对象，只需要被动接受Spring容器创建好的对象</li><li>一句话：对象由Spring创建，管理，装配</li></ul><ol start="5"><li>接上：</li></ol><ul><li>bean中的property基本类型用value，引用类型用ref;其中property必须搭配Set方法使用</li><li>property的name是xxx,则方法为setXxx,例如property的name=”te”,那么对应类中需要setTe(Object ob)方法,命名规范严格遵照驼峰规则</li></ul><ol start="6"><li>IOC对象创建</li></ol><ul><li>无参构造函数</li><li>有参构造函数：可以使用多种方式在配置文件中赋值没具体查阅Spring文档</li></ul><ol start="7"><li>当使用<code>ClassPathXMLApplication(&quot;bean.xml&quot;)</code>即配置文件加载后，只要beans.xml中配置了bean,即使没有调用，也会创建对象，可以使用无参构造函数测试这种情况，且一个beans在容器中只创建了一个</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="8"><li>使用别名标签给同一个类可以取多个名字，还可以直接在bean中使用name取别名，同一个name中取多个别名可以用逗号或空格分割</li><li>在XML配置文件中可以用<code>import</code>标签导入其他配置文件</li><li>多种不同类的属性的具体注入方式看Spring官方文档</li><li>namespace: 命名空间，防止命名冲突；一般有统一的命名格式</li></ol><ul><li>Spring中有P命名空间，<code>&lt;p:name=&quot;...&quot;&gt;&lt;/p&gt;</code>给属性赋值</li><li>Spring中有C命名空间,给有参构造器赋值</li><li>使用需要导入约束</li></ul><ol start="12"><li>bean作用域：</li></ol><ul><li>单例模式: Spring默认机制</li><li>原型模式: 每次从容器中get时，都会产生一个新引用</li><li>还有部分作用域涉及到Web</li></ul><ol start="13"><li>自动装配：</li></ol><ul><li><code>autowire=&quot;byName&quot;</code>,byName是自动在容器中查找，根据set方法后的名字来装配，遵循驼峰命名规则</li><li>除了<code>byName</code>还有<code>byType</code>等等，<code>byType</code>要求同类(bean)唯一,默认<code>byType</code></li></ul><ol start="14"><li>XML配置实现的功能，同样也能使用注解实现，注解要求JDK1.5和Spring2.5</li></ol><ul><li>注解同样需要导入约束</li><li>使用<code>@Autowired</code>可以省略掉set方法,包含<code>@Autowired</code>的类文件同样要在bean中配置</li><li>同一个类有多个bean时，<code>@Autowired</code>需要搭配<code>@Qualifier</code>使用<code>@Qualifier(value=&quot;&quot;)</code>选取特定的bean的id</li><li>Java中有个<code>@Resource(name=&quot;&quot;)</code>，name可以不写，类似<code>@Autowired + @Qualifier(value=&quot;&quot;)</code>的功能</li></ul><ol start="15"><li><code>&lt;context:component-scan base-package=&quot;包名1 包名2...&quot;/&gt;</code>扫描指定包，搭配写在项目中的<code>@Component</code>使用；把普通pojo实例化到spring容器中：</li></ol><ul><li>对上面的解释： 写了<code>@Component</code>的类就相当于在配置文件中写了bean，bean的id默认为类的小写名字(实际上配置文件中没有显式写出这个类的bean)</li><li>使用<code>@Value(&quot;&quot;)</code>给属性赋值</li></ul><ol start="16"><li><code>@Configuration</code>方式也可以配置bean,结合<code>@component(&quot;完全版类名&quot;)</code>指定类文件，在需要的方法前一行<code>@Bean</code>，在使用时使用<code>AnnotationConfigApplicationContext(参数)</code>，然后<code>getBean(&quot;方法名&quot;)</code>； 与XML配置的操作类似</li><li>代理模式：可以在不修改原有代码的基础上对某些功能进行增加</li><li>面向切面(AOP)：Spring版动态代理</li><li>AOP实现:先导入实现AOP的jar包，再将自己写的增强版的类用bean注入容器</li></ol><ul><li>配置文件版: <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>以上非完全版，具体以Spring文档为准，暂时不细查，等到项目实战中再细化</p><ul><li>注解版：<code>@Aspect</code>,<code>@Before</code>等等，同样需要在配置文件中配置，具体查Spring，大概在Spring文档的5.4节中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片问题</title>
    <link href="/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今日问题</p><h2 id="外链图片加载失败"><a href="#外链图片加载失败" class="headerlink" title="外链图片加载失败"></a>外链图片加载失败</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ol><li>可能是由于服务器检测到请求头中的refer不是自家域名，为了减轻服务器压力，拦截访问</li></ol><ul><li>学习资料： <a href="https://blog.csdn.net/qq_42248939/article/details/97377126" target="_blank" rel="noopener">https://blog.csdn.net/qq_42248939/article/details/97377126</a></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>下载到本地访问</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2020/02/26/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/26/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Java新手上路，谨以此记录自己的第一个博客笔记</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><code>Public</code>类的名字与文件名一致</li><li>类的构造器(默认存在且其权限修饰符与所属类一致，也可以自己编写)，父类构造器不能被子类继承</li><li>可变个数的参数：如<code>public void test (String...args){}</code></li><li>四种访问权限修饰符：private(类内部使用),default(类内部+包）,protected(类内部+包+子类),public(任何地方)</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="5"><li>关键字this：当前正在引用的对象或者当前正在初始化的对象，<code>this(.....)</code>可用来调用构造器<br>要求：</li></ol><ul><li>必须存在未使用<code>this()</code>调用的构造器  </li><li><code>this()</code>调用要放在首行。若本类没有则在父类查找</li></ul><ol start="6"><li>JavaBean:拥有Set和Get方法的公共类且属性私有，一种可重用组件</li><li>类的继承只能有一个父类(单继承)，若对继承类方法重写，权限限定比原方法严格（如原方法是public,重写后的方法就是public而不能是protected）</li></ol><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><ol start="8"><li><code>Super</code>用于调用父类中的指定操作，不局限于直接父类，还可以对多层继承父类调用，且Super调用写在第一行</li><li>子类要调用父类构造器，默认调用父类无参构造器。若父类没有无参构造器，则自需要手动调用，</li><li><code>Super</code>和<code>this</code>调用构造器只能使用其中一个，因为两者都要求占据第一行</li><li>子对象实例化过程：</li></ol><ul><li>先加载父类字节码，在加载子类字节码. </li><li>在堆内存中开辟空间并分配地址，默认初始化. </li><li>子类构造函数进栈，显式初始化父类属性. 四、父类构造方法进栈，显式初始化子类属性，执行完后父类构造方法出栈<br>五、显式初始化子类属性，返回地址给引用变量，子类构造方法出栈.</li></ul><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><ol start="12"><li>多态存在的三个必要条件：继承，重写，父类引用指向子类对象(例如:student继承person类，student中重写了person的show方法，{person e = new student();e.show()动态绑定，最终输出的是子类student中的show})。方法形参为父类，可以传参时传入子类，调用参数的方法时会用到多态</li><li>Instanceof操作符：<code>x instanceof A</code>：检验对象x是否是类A的对象，返回值为boolean(若x instanceof A为true,x instanceof A的父类,也为true)</li><li>==：基本类型比较是值等则为true，引用类型比较则是指向同一个对象才返回true；equals()当比较例如String类是比较String的值相同则为true，而不是比较是否指向同一个对象</li><li>包装类：<code>boolean b=new Boolean(“true”)</code>这是自动拆箱，<code>Boolean b=true</code>这是自动装箱，都是在JDK1.5后支持。包装类方便基本类型与字符串的转换</li><li><code>System.out.println(x)//若X是对象</code>，则相当于输出<code>x.toString()</code>.</li><li>用static修饰的方法和变量可以直接用(类名.方法)调用，随着类的加载而加载，被所有对象共享</li><li>单例模式：用static创建变量，进行一次实例化，共同使用，分为1.饿汉式 2.懒汉式(两者区别，饿汉式在类实例化时就创建，懒汉式在调用<code>getInstance()</code>方法时才创建)</li><li>代码块先于构造器初始化,静态代码块值执行一次</li><li>匿名内部类用于隐式继承父类或实现接口，可以在匿名内部类中用代码块初始化</li><li><code>final</code>修饰的类不能被继承，<code>final</code>修饰的变量不能被修改且必须显示赋值，<code>final</code>饰的方法不能被子类重写</li></ol><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><ol start="22"><li>Abstract修饰抽象方法和抽象类，抽象类不能实例化，但可以由构造器，继承抽象类的子类必须重写抽象类中的抽象方法，抽象方法是只有声明没有实现。若某类中有抽象方法，则该类必须声明为抽象类</li><li>模板设计模式：定义一个抽象类，定义一个抽象类，子类继承抽象类，可以直接使用而不用重写部分已经写好的通用方法。</li><li>接口与抽象类的区别：</li></ol><ul><li>接口中（默认<code>public abstract</code>） 只能声明方法而不能实现方法2.接口中的变量只能是<code>public static final</code>类型的</li><li>接口不能含有静态代码块、静态方法以及构造器 4.一个类只能继承一个抽象类，但是却可以实现多个接口</li></ul><ol start="25"><li>工厂模式：</li></ol><ul><li>定义接口，将实现同一接口的不同类放入工厂，并延迟到子类再决定实例化哪一个类。  </li><li>定义一个产品接口 2.创建多个实现接口的不同实体类</li><li>创建一个工厂，基于开发者对实体类的需求返回类</li></ul><ol start="26"><li>内部类也是类，但特殊点在若内部类是<code>static</code>修饰，就不能使用外部类的非static的成员变量。而非static的内部类中的成员不能声明为static（内部类主要用来解决JAVA不能多层继承的问题）</li><li>异常问题，子类不能抛出比父类更大范围的异常</li><li>Java分为三大集合：</li></ol><ul><li>Set,Map,List</li><li><code>set和list</code>使用<code>iterator</code>或者foreach迭代</li></ul><ol start="29"><li><code>treeSet</code>有序，<code>treeMap</code>有序</li><li>Map使用keySet或者entrySet遍历</li><li>Collections工具</li></ol><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><ol start="32"><li>泛型：</li></ol><ul><li>泛型类；</li><li>泛型接口：实现泛型接口时如果不具体指定类型，则实现类也需要加上泛型（例如<code>class A&lt;T&gt; implements interfa&lt;T&gt;</code>）；</li><li>泛型方法：<code>public &lt;T&gt; void test(T t){}</code>在静态方法中不能使用类定义泛型，若需要使用，只能使用静态方法自己定义的泛型<code>public static &lt;T&gt; void test(T t){}</code></li></ul><ol start="33"><li>通配符是“？”：</li></ol><ul><li><code>&lt;? extends Person&gt;</code>表示通配只接受Person及其子类的引用</li><li><code>&lt;? super Person&gt;</code>表示通配只接受Person及其父类的引用</li><li><code>&lt;？Extends Comparable&gt;</code>表示通配只接受实现<code>Comparable接口</code>的类的引用</li></ul><ol start="34"><li>枚举类:<br><code>Season summer = Season.SUMMER;Summer.showInfo();</code><br>每个枚举都是单例模式</li><li>注解：编写注解需要使用@interface声明，在注解前面也需要加其他注解来限制编写的注解的作用范围：如下</li><li>文件流：File类：其中，<code>File.separator</code>为当前系统分隔符，File只能操作文件本身，比如删除文件，但不能改变文件的内容</li><li>文件流：<code>FileOutputStream</code>输出流（字节流），将数据输出到某文件，<code>FileInputStream</code>输入流（字节流），从某文件中获取数据输入（可用byte数组存储）。<code>FileReader</code>输入流（字符流，可以char数组存储）</li><li>缓冲流：先将数据放入内存中，再在内存中操作数据，提升性能。<code>BufferedInputStream</code>和<code>BufferedOutputStream</code></li><li>转换流：<code>InputStreamReader</code>等等。。不同文本格式的转换，比如GBK到UTB-8</li><li>标准输入输出流</li><li>对象流：序列化和反序列化（包名，类名等要完全一致）</li><li>反射机制：前提是JVM已经加载过这个类<br>反射机制中的Class代表该字节码文件，Class类是JVM创建的表类信息的类，而Object是所有类的父类，可以利用<code>Class.class.isAssignableFrom(Object.class)</code>来判断子类父类关系<br>可以利用反射机制调用类的私有方法和私有变量（这类操作会破坏类的封装性）</li><li>Java动态代理：当需要修改方法执行前或执行后的操作时，利用动态代理可以简化操作，想要通过<code>Proxy.newProxyInstance</code>方法被代理则此对象的类需要实现接口<br>JDK实现：</li></ol><ul><li>自己定义的接口 </li><li>实现这个接口 </li><li>实现<code>InvocationHandler</code>接口</li><li>利用第三步中的类获取代理类，调用方法（JVM会自动生成Proxy类文件，调用InvocationHandler接口中实现Invoke方法达到最终目的）</li></ul><ol start="44"><li>Java静态代理和动态代理讲解：</li></ol><ul><li><a href="https://www.jianshu.com/p/9bcac608c714" target="_blank" rel="noopener">https://www.jianshu.com/p/9bcac608c714</a></li><li><a href="https://www.bilibili.com/video/av63885236" target="_blank" rel="noopener">https://www.bilibili.com/video/av63885236</a></li></ul><ol start="45"><li>创建线程：</li></ol><ul><li>继承<code>thread</code>类  </li><li>实现<code>Runnable</code>接口</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>博客测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/25/hello-world/"/>
    <url>/2020/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
