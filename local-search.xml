<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Spring实战》笔记</title>
    <link href="/2020/03/19/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/19/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>Spring变迁历史以及整体概览</li><li>通过构造器和接口可以实现依赖注入</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol start="3"><li>创建对象之间协作关系的行为通常称为装配，这也是依赖注入的本质</li><li>Spring主要提供了三种装配方式：</li></ol><ul><li>在XML中进行显式配置</li><li>在Java中进行显式配置</li><li>隐式的bean发现机制和自动装配</li></ul><ol start="5"><li><code>@ComponentScan</code>默认扫描配置类相同的包下带有<code>@Component</code>的类；在XML中有类似的功能，<code>&lt;context:component-scan base-package=&#39;...&#39;&gt;</code>可以启动此功能</li><li>需要<code>spring-test</code>,<code>spring-context</code>,<code>junit</code>三个jar包，在使用maven导包时多导入了<code>spring-web</code>的jar包运行就一直报错，删除这个jar包就可以正常运行(文章2.2.1笔记)</li><li><code>@RunWith(SpringJUnit4ClassRunner.class)</code>注解用来在测试开始时自动创建Spring应用上下文<br><code>@ContextConfiguration(classes = CDConfig.class)</code>注解用来表示在什么地方加载配置，示例中表示在CDConfig中加载配置，CDConfig是一个包含有<code>@ComponentScan</code>注解的类</li><li><code>@Autowired</code>和<code>@Inject</code>大多数情况可以相互替换，前者来自Spring，后者来自Java依赖注入规范</li><li><code>@Bean</code>+<code>@Configuration</code>在Java中可以用来替代XML配置bean</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol start="10"><li>使用<code>@profile</code>可以简化不同环境的配置，通过spring.profiles.active和spring.profiles.default来激活profile，active的优先级高于default；如果active和default都不存在，则没有激活的profile，因此只会创造那些没有定义在profile的bean</li><li>待续…</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记</title>
    <link href="/2020/03/06/MyBatis%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/06/MyBatis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>MyBatis是一款针对数据库的持久层框架，它避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的<code>XML</code>或<code>注解</code>来配置和映射原生类型、接口和 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</li><li>导入MySQL的jar是5.1.47版本的</li><li>MyBatis问题解决: </li></ol><ul><li><img src="/img/blogpic/mybatis.jpg" alt="avatar">图中在try-catch中用<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>再次创建了新的变量而覆盖了开始声明的变量；但是这个变量在try-catch中，出了try-catch就不再存在了，而<code>private static SqlSessionFactory sqlSessionFactory = null;</code>已经声明了这个变量，所以最后返回值出了问题；将<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>改为<code>sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></li></ul><p><strong>如图</strong><img src="/img/blogpic/mybatis1.jpg" alt="avatar"></p><ul><li>上面的问题小结: 在try-catch中new的对象在try-catch外的范围不能使用；而上图中误将已经声明的变量在try-catch中再重新声明了一次，所以最后的返回值是null，而不是try-catch中读取的XML文件</li><li>执行时找不到UserDao的UserMapper的配置文件，在maven中如下配置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>但是出现这种问题的原因不知道，有待查询；先把mybatis跑起来再说</li><li>贴个博客: <a href="https://www.cnblogs.com/aflyun/p/6780117.html" target="_blank" rel="noopener">https://www.cnblogs.com/aflyun/p/6780117.html</a></li></ul><ol start="4"><li><pre><code>&lt;mapper namespace=&quot;com.my.dao.UserDao&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.my.pojo.User&quot;&gt;     select * from wo&lt;/select&gt;&lt;/mapper&gt;</code></pre>id是namespace指定的类中的方法名</li><li>特殊方法; 使用Map方法的键值对，匹配SQL语句中的查询字段；<code>#{字段名}</code>中的字段名只需要和Map中的键对应，而不用创建单独的类文件来与属性名对应，比较万能，但是非标准(这里解释得比较模糊，想得起来就用，想不起来就老老实实单独写个类对应XML文件中的字段)</li><li>当properties配置文件和properties的属性值冲突时，以外部配置文件的值为准</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="7"><li>Java实体类中的属性名需要与数据库字段名相同(这是在网上视频中提出的问题，我在自己的环境下测试int型字段不受影响，String类型的变量会受到这种影响)</li><li>项目简单或者SQL语句不复杂可以使用注解简化操作，但是更多情况是使用XML配置文件</li><li>MyBatis有些类似<code>&lt;where&gt;</code>的标签，在动态SQL文档中可以找到具体介绍</li><li>MyBatis缓存有一级缓存和二级缓存,缓存的存在是为了优化性能</li></ol><ul><li>一级缓存即本地的会话缓存，可以使用SqlSession测试或者清除，它仅仅对一个会话汇总的数据进行缓存</li><li>二级缓存即全局缓存，一级缓存会被提升到二级缓存，作用域扩大(大概意思是这样，不太严谨)，接下来贴个官方文档的解释: <code>二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新</code></li><li>缓存查询顺序，惯例贴个博客: <a href="https://www.cnblogs.com/yanl55555/p/11936765.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanl55555/p/11936765.html</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记</title>
    <link href="/2020/03/04/SpringMVC%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/04/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>SpringMVC是一种基于Java实现的Web框架：Model(模型层) + View(视图层) + Controller(控制层)</li><li><code>/</code>和<code>/*</code>和<code>/**</code>：可以使用前端控制器测试，<code>/</code>不会拦截例如带.jsp后缀的文件，而<code>/*</code>会拦截所有文件，包括带.jsp后缀的文件(个人猜想: <code>/</code>匹配规则是文件夹匹配，而<code>/*</code>是贪婪匹配，文件夹和文件都匹配),<code>/**</code>拦截文件夹和子文件夹</li><li><code>classpath:</code>和<code>classpth*:</code>: 不带星号的只在classpath只在第一个加载的类路径下查找并加载第一个同名文件，带星号的classpath会在classpath路径中查找并加载所有的同名文件(按照下面案例的说法，虽然加载了所有同名文件，但是似乎并不是所有都会生效，部分会被覆盖掉；有待证实;还有可能是Maven存在资源过滤的问题,以后碰到了再回来翻博客)</li></ol><ul><li>贴个博客: <a href="https://www.cnblogs.com/mumu122GIS/p/10161725.html" target="_blank" rel="noopener">https://www.cnblogs.com/mumu122GIS/p/10161725.html</a></li><li>贴个博客: <a href="https://www.cnblogs.com/chenmingjun/p/10264644.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenmingjun/p/10264644.html</a></li><li>贴个案例: <a href="https://www.jianshu.com/p/5263e3a6cde2" target="_blank" rel="noopener">https://www.jianshu.com/p/5263e3a6cde2</a></li></ul><ol start="4"><li>使用tomcat测试SpringMVC流程时始终网页报404,排查发现lib文件放在了class文件夹下面，正确位置lib应该放在WEB-INF文件夹下，然后 再导入jar包，重新启动tomcat</li><li>测试SpringMVC流程(XML+接口版): </li></ol><ul><li>启动tomcat，解析web.xml,发现了<code>DispatcherServlet</code>，其配置文件的位置由classpath指定，进入到classpath指定的位置解析<code>springmvc-servlet.xml</code>配置文件</li><li><code>springmvc-servlet.xml</code>配置文件中有处理器映射器，处理器适配器和视图解析器，再有一个bean绑定实现了<code>Controller接口</code>的类，这个类实现了<code>Controller接口</code>的<code>ModelAndView</code>方法; 注意这个bean中的id名字前后有加<code>/</code>,这相当于<code>url-pattern</code></li><li><code>springmvc-servlet.xml</code>配置文件解析完成后，进入Controller中执行代码，返回测试信息，成功完成</li><li><img src="/img/blogpic/springmvc.jpg" alt="avatar"></li><li>过程中还有些关于文件目录的配置</li><li>这行留给以后填坑</li></ul><ol start="6"><li>注解版: <img src="/img/blogpic/anno.jpg" alt="avatar"><br><img src="/img/blogpic/controller.jpg" alt="avatar"></li><li>RESTful是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义</li></ol><ul><li>贴个博客: <a href="https://www.jianshu.com/p/ee92c9accedd" target="_blank" rel="noopener">https://www.jianshu.com/p/ee92c9accedd</a></li><li>贴个博客: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li><li>针对这类情况有专门的<code>@PostMapping</code>或<code>@GetMapping</code>等等这类的组合起来的注解</li><li>貌似RESTful没有完全统一的标准，只有宏观上的定义</li></ul><ol start="8"><li>不用视图解析器可以直接<code>return forward:...</code>,<code>return ...</code>,<code>return redirect:...</code></li><li>关于<code>return redirect:...</code>和<code>return forward:...</code>这两个方法都不受视图解析器的影响，不管视图解析器存在与否，都不会影响；重定向相当于拼接地址直接访问，所以对于WEB-INF下面的文件不能访问；而转发则可以访问WEB-INF下面的文件</li><li>当需要在URL地址栏传递对象参数时，地址栏的参数名字要和对象中的参数名字相同</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web笔记</title>
    <link href="/2020/03/02/Web%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/02/Web%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>HTTP(超文本传输协议): 基于<code>TCP/IP</code>，默认端口号80，无状态(同一个连接中，两次成功请求间没有联系)</li></ol><ul><li>HTTP不需要传输层是面向连接的，只需要它是可靠的，由于<code>UDP</code>不可靠，<code>TCP</code>可靠，所以HTTP的传输层协议是<code>TCP/IP</code></li><li>HTTP/1.0默认为每一次请求/响应都打开单独的TCP连接</li><li>HTTP/1.1引入流水线和持久连接的概念，通过Connection头部来被控制，并且具有协议升级机制</li><li>HTTP/2是二进制协议，其HTTP报文被封装在帧中，一般使用HTTP/2来替代HTTP/1.1中的流水线功能</li></ul><ol start="2"><li>HTTP安全策略:</li></ol><ul><li>内容安全策略(CSP)</li><li>HTTP公钥锁定(HPKP)</li><li>HTTP严格传输安全(HSTS)</li><li>还有部分其他的安全策略</li></ul><ol start="3"><li>HTTP的跨域资源共享(CORS): 使用额外的HTTP头告诉浏览器来允许运行在一个域上的Web应用访问来自不同源服务器上的资源；<br>当一个资源从与该资源本身所在的服务器<strong>不同的域</strong>、<strong>协议</strong>或<strong>端口</strong>请求一个资源时，资源会发起一个跨域 HTTP 请求。</li><li>HTTP缓存:</li></ol><ul><li>对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。</li><li>通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。</li><li>如果max-age和expires属性都没有，就找头里的Last-Modified信息。若有，缓存的寿命就等于头里面Date的值减去Last-Modified的值乘以10%<br><code>缓存失效时间计算公式如下: expirationTime = responseTime + freshnessLifetime - currentAge；式中，responseTime表示浏览器接收到此响应的那个时间点。</code></li></ul><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="5"><li>URL重定向: 客户端发起请求给服务器端，当servlet方法执行到重定向时，则反馈给客户端这个响应，客户端根据这个响应再访问新的网址，两次不同地址的请求相互独立。<br>URL转发:客户端发起请求给服务器，当servlet方法执行到转发时，则仍然在服务器端执行转发请求，这种情况下的整个流程都是在一个request完成的；另外转发还分为显示转发和隐式转发。</li></ol><ul><li>以上对比都是基于Servlet中的<code>request.getRequestDispatcher(&quot;...&quot;).forword(request, response)</code>;和<code>response.sendRedirect(&quot;...&quot;)</code></li><li>重定向和转发之间的区别除了性能还有对网站权重的影响，水平不够，只做记载，水平够了再深入学习</li><li>贴个关于重定向和转发博客地址: <a href="https://www.cnblogs.com/yanggb/p/11825019.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanggb/p/11825019.html</a></li></ul><ol start="6"><li>Cookie: 服务器发送到用户浏览器并保存在本地的一小块数据，在下次浏览器向同一服务器发起请求时被携带发送到服务器，保持用户状态；Cookie大小有限制，Cookie数量有限制；由于Cookie会引起额外的性能开销，有新的浏览器API已经允许开发者直接将数据存储在本地</li><li>Session: 服务器端Cookie</li></ol><ul><li>贴个关于Cookie和Session的博客: <a href="https://www.iteye.com/blog/justsee-1570652" target="_blank" rel="noopener">https://www.iteye.com/blog/justsee-1570652</a></li><li>再贴个关于Session的博客: <a href="https://blog.csdn.net/weixin_42217767/article/details/92760353" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42217767/article/details/92760353</a></li></ul><ol start="8"><li>多用途互联网邮件扩展类型(MIME): 描述消息内容类型的因特网标准；当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AJAX+JSON笔记</title>
    <link href="/2020/03/02/AJAX+JSON%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/02/AJAX+JSON%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>AJAX定义: <a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/ajax/index.asp</a></li><li>有更好的笔记就不写了自己的笔记了</li></ol><ul><li>贴个博客链接: <a href="https://segmentfault.com/a/1190000004322487#articleHeader0" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322487#articleHeader0</a></li><li>贴个教程链接: <a href="https://www.w3school.com.cn/xmldom/dom_http.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xmldom/dom_http.asp</a></li></ul><ol start="3"><li>JSON: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON</a></li></ol><ul><li>记录: <a href="http://www.json.org.cn/resource/index.htm" target="_blank" rel="noopener">http://www.json.org.cn/resource/index.htm</a></li></ul><p>PS: 以上部分文章等以后水平够了再回来重读填坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><p>MySQL是关系型数据库的一种，另外还有非关系型数据库</p></li><li><p>命令行操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 密码 --注意区分p的大小写，大小写p分别表示端口和密码&lt;br&#x2F;&gt;</span><br><span class="line">update mysql.user set authentication_string&#x3D;password(&#39;密码&#39;)where user&#x3D;&#39;root&#39; and Host&#x3D;&#39;Localhost&#39;;--修改用户密码</span><br><span class="line">flush privileges; --刷新权限</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">show databases; -- 查看所有的数据库</span><br><span class="line"></span><br><span class="line">exit；</span><br></pre></td></tr></table></figure><p>PS: 敲完代码敲回车，在第二行输入<code>;</code>再敲回车命令结果就会回显，或者直接语句后面加<code>;</code>再敲回车同样会回显<br>PS: 剩下的懒得写了，命令行语句百度查询</p></li><li><p>MySQL语句: 中括号代表可选操作</p><blockquote><p><code>CREATE DATABASE [IF NOT EXISTS] yuexinbaiwan      --创建数据库</code><br><code>DROP DATABASE IF EXISTS yuexinbaiwan      --删除数据库</code></p></blockquote></li><li><p>MySQL引擎: InnoDB和MyISAM</p></li><li><p>修改表名: <code>ALTER TABLE 原表名 RENAME AS 目标表名</code><br>修改约束: <code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(11)</code><br>修改字段名: <code>ALTER TABLE 表名 CHANGE 原字段名 目标字段名 INT(1)</code><br>增加表字段: <code>ALTER TABLE 表名 ADD 字段名 INT(11)</code><br>删除表字段: <code>ALTER TABLE 表名 DROP 字段名</code><br>删除表: <code>DROP TABLE IF EXISTS 表名</code><br>注: 大小写不敏感</p></li><li><p>外键: 减少使用外键和级联可以简化开发和测试</p></li><li><p>修改具体数据: <code>UPDATA 表名 SET 字段名=&quot;...&quot; where 约束条件</code>(修改数据必须加约束条件，不然会默认修改该字段所有数据)<br><code>PS: 使用时再查找相关文档细化知识</code></p></li><li><p>删除具体数据: <code>DELETE FROM 表名 [where 约束条件]</code><br>清空表: <code>TRUNCATE 表名</code></p></li></ol><ul><li><code>DELETE</code>和<code>TRUNCATE</code>的异同点: 两者都删除数据，但不会删除表结构，不同的是使用<code>TRUNCATE</code>不影响事物，且重新设置自增列，计数器归零<br>而<code>DELETE</code>不会影响自增量</li><li>补充: 自增量在InnoDB中是存在内存中，断电即失；而在MyISAM则继续从上一个自增量开始，存在文件中，不会断电即失</li></ul><ol start="9"><li>查询+别名: <code>SELECT 字段名 AS 别名,字段名 AS 别名  FROM  表名</code>(表名也可以加别名)<br>查询+拼接: <code>SELECT CONTACT(&#39;需要拼接的数据&#39;,字段名) AS 别名 FROM 表名</code><br>查询+去重: <code>SELECT DISTINCT 字段名 FROM 表名</code><br><code>PS: 还有许多，具体查阅文档</code></li><li>MySQL运算符: 算术运算符，比较运算符，逻辑运算符，位运算符</li><li>在模糊查询中注意<code>%</code>和<code>_</code>的区别</li><li>联表查询的七种join理论: <img src="/img/blogpic/join.jpg" alt="avatar"></li><li>自连接+联表查询</li><li>查询结果排序: <code>ORDER BY [ASC|DSC]</code>(升序|降序)</li><li>查询结果分页: <code>LIMIT 6,5 //检索记录7-11行</code>或者<code>LIMIT 5 //检索记录前5行，相当于LIMIT 0,5</code>,<br>即<code>LIMIT 起始值 [,检索数目]</code>(LIMIT中计数默认从0开始；即第0行，第1行)</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="16"><li>MySQL也有函数，例如第九条中的CONTACT(): 可查询文档或菜鸟教程</li><li><code>coalesce(name, &#39;总数&#39;)</code>和<code>WITH ROLLUP</code></li><li>MD5加密: <code>UPDATE 表名 SET pwd=MD5(pwd) where 约束条件</code>或者插入时加密: <code>INSERT INTO 表名 VALUES(...,...,MD5(...))</code></li><li>事物(满足ACID原则): <code>SAVEPOINT(保存点)</code>  <code>RELEASE SAVEPOINT</code>  <code>ROLLBACK TO SAVEPOINT</code></li><li>索引: 在数据量庞大的时候能极大的优化性能:<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li></ol><ul><li>博客读后感: 基础设施决定上层建筑，要学习的东西还有很多很多</li><li><code>EXPLAIN SELECT</code>(相比<code>SELECT</code>会显示一些特别的信息)</li></ul><ol start="21"><li>数据库备份</li><li>使用Java中的<code>PreparedStatement</code>防止SQL注入</li><li>关系型数据库范式: 第一范式要求每一列中的信息都不可分割，第二范式要求每一列都与所有主键完全依赖(或者说相关)，第三范式要求每一列信息直接依赖，不能间接相关(例如A -&gt; B,B -&gt; C；那么A和B在一张表，B和C则应放在另一张表)<br>PS: 上文中的(依赖)可以换成(相关)，这样更通俗；上文的总结完全依赖于下面两个链接中的精华，第一个链接精炼，第二个链接通俗<br><a href="https://www.jianshu.com/p/08d123026438" target="_blank" rel="noopener">https://www.jianshu.com/p/08d123026438</a><br><a href="https://www.cnblogs.com/wsg25/p/9615100.html" target="_blank" rel="noopener">https://www.cnblogs.com/wsg25/p/9615100.html</a></li><li>数据库连接池</li></ol><p>PS: 了解的东西多了，才发现还要学习的东西更多</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/2020/02/27/Spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/27/Spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>Spring是非入侵式框架，基于Interface21框架；IOC+AOP+事物处理</li><li>控制反转(IOC): 对象的创建与对象间的依赖关系完全硬编码在程序中并由程序自己控制，而控制反转则将控制权转移给第三方； 可以利用依赖注入(DI)实现</li><li>有XML和注解两种实现IOC</li><li>XML:</li></ol><ul><li>使用Spring来创建对象，在Spring中都称为bean</li><li>在bean中来实现对象的属性赋值</li><li>这种情况下，程序不用new对象，只需要被动接受Spring容器创建好的对象</li><li>一句话: 对象由Spring创建，管理，装配</li></ul><ol start="5"><li>接上:</li></ol><ul><li>bean中的property基本类型用value，引用类型用ref;其中property必须搭配Set方法使用</li><li>property的name是xxx,则方法为setXxx,例如property的name=”te”,那么对应类中需要setTe(Object ob)方法,命名规范严格遵照驼峰规则</li></ul><ol start="6"><li>IOC对象创建</li></ol><ul><li>无参构造函数</li><li>有参构造函数: 可以使用多种方式在配置文件中赋值没具体查阅Spring文档</li></ul><ol start="7"><li>当使用<code>ClassPathXMLApplication(&quot;bean.xml&quot;)</code>即配置文件加载后，只要beans.xml中配置了bean,即使没有调用，也会创建对象，可以使用无参构造函数测试这种情况，且一个beans在容器中只创建了一个</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="8"><li>使用别名标签给同一个类可以取多个名字，还可以直接在bean中使用name取别名，同一个name中取多个别名可以用逗号或空格分割</li><li>在XML配置文件中可以用<code>import</code>标签导入其他配置文件</li><li>多种不同类的属性的具体注入方式看Spring官方文档</li><li>namespace: 命名空间，防止命名冲突；一般有统一的命名格式</li></ol><ul><li>Spring中有P命名空间，<code>&lt;p:name=&quot;...&quot;&gt;&lt;/p&gt;</code>给属性赋值</li><li>Spring中有C命名空间,给有参构造器赋值</li><li>使用需要导入约束</li></ul><ol start="12"><li>bean作用域:</li></ol><ul><li>单例模式: Spring默认机制</li><li>原型模式: 每次从容器中get时，都会产生一个新引用</li><li>还有部分作用域涉及到Web</li></ul><ol start="13"><li>自动装配:</li></ol><ul><li><code>autowire=&quot;byName&quot;</code>,byName是自动在容器中查找，根据set方法后的名字来装配，遵循驼峰命名规则</li><li>除了<code>byName</code>还有<code>byType</code>等等，<code>byType</code>要求同类(bean)唯一,默认<code>byType</code></li></ul><ol start="14"><li>XML配置实现的功能，同样也能使用注解实现，注解要求JDK1.5和Spring2.5</li></ol><ul><li>注解同样需要导入约束</li><li>使用<code>@Autowired</code>可以省略掉set方法,包含<code>@Autowired</code>的类文件同样要在bean中配置</li><li>同一个类有多个bean时，<code>@Autowired</code>需要搭配<code>@Qualifier</code>使用<code>@Qualifier(value=&quot;&quot;)</code>选取特定的bean的id</li><li>Java中有个<code>@Resource(name=&quot;&quot;)</code>，name可以不写，类似<code>@Autowired + @Qualifier(value=&quot;&quot;)</code>的功能</li></ul><ol start="15"><li><code>&lt;context:component-scan base-package=&quot;包名1 包名2...&quot;/&gt;</code>扫描指定包，搭配写在项目中的<code>@Component</code>使用；把普通pojo实例化到spring容器中:</li></ol><ul><li>对上面的解释: 写了<code>@Component</code>的类就相当于在配置文件中写了bean，bean的id默认为类的小写名字(实际上配置文件中没有显式写出这个类的bean)</li><li>使用<code>@Value(&quot;&quot;)</code>给属性赋值</li></ul><ol start="16"><li><code>@Configuration</code>方式也可以配置bean,结合<code>@component(&quot;完全版类名&quot;)</code>指定类文件，在需要的方法前一行<code>@Bean</code>，在使用时使用<code>AnnotationConfigApplicationContext(参数)</code>，然后<code>getBean(&quot;方法名&quot;)</code>； 与XML配置的操作类似</li><li>代理模式: 可以在不修改原有代码的基础上对某些功能进行增加</li><li>面向切面(AOP): Spring版动态代理</li><li>AOP实现: 先导入实现AOP的jar包，再将自己写的增强版的类用bean注入容器</li></ol><ul><li>配置文件版: <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>以上非完全版，具体以Spring文档为准，暂时不细查，等到项目实战中再细化</p><ul><li>注解版: <code>@Aspect</code>,<code>@Before</code>等等，同样需要在配置文件中配置，具体查Spring，大概在Spring文档的5.4节中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片问题</title>
    <link href="/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今日问题</p><h2 id="外链图片加载失败"><a href="#外链图片加载失败" class="headerlink" title="外链图片加载失败"></a>外链图片加载失败</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ol><li>可能是由于服务器检测到请求头中的refer不是自家域名，为了减轻服务器压力，拦截访问</li></ol><ul><li>学习资料: <a href="https://blog.csdn.net/qq_42248939/article/details/97377126" target="_blank" rel="noopener">https://blog.csdn.net/qq_42248939/article/details/97377126</a></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>下载到本地访问</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2020/02/26/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/26/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Java新手上路，谨以此记录自己的第一个博客笔记</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><code>Public</code>类的名字与文件名一致</li><li>类的构造器(默认存在且其权限修饰符与所属类一致，也可以自己编写)，父类构造器不能被子类继承</li><li>可变个数的参数: 如<code>public void test (String...args){}</code></li><li>四种访问权限修饰符: private(类内部使用),default(类内部+包）,protected(类内部+包+子类),public(任何地方)</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="5"><li>关键字this: 当前正在引用的对象或者当前正在初始化的对象，<code>this(.....)</code>可用来调用构造器<br>要求:</li></ol><ul><li>必须存在未使用<code>this()</code>调用的构造器  </li><li><code>this()</code>调用要放在首行。若本类没有则在父类查找</li></ul><ol start="6"><li>JavaBean: 拥有Set和Get方法的公共类且属性私有，一种可重用组件</li><li>类的继承只能有一个父类(单继承)，若对继承类方法重写，权限限定比原方法严格（如原方法是public,重写后的方法就是public而不能是protected）</li></ol><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><ol start="8"><li><code>Super</code>用于调用父类中的指定操作，不局限于直接父类，还可以对多层继承父类调用，且Super调用写在第一行</li><li>子类要调用父类构造器，默认调用父类无参构造器。若父类没有无参构造器，则需要手动调用其他构造函数</li><li><code>Super</code>和<code>this</code>调用构造器只能使用其中一个，因为两者都要求占据第一行</li><li>子对象实例化过程:</li></ol><ul><li>先加载父类字节码，在加载子类字节码. </li><li>在堆内存中开辟空间并分配地址，默认初始化. </li><li>子类构造函数进栈，显式初始化父类属性. </li><li>父类构造方法进栈，执行完后父类构造方法出栈</li><li>显式初始化子类属性，返回引用地址给变量，子类构造方法出栈.</li></ul><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><ol start="12"><li>多态存在的三个必要条件: 继承，重写，父类引用指向子类对象(例如: student继承person类，student中重写了person的show方法，{person e = new student();e.show()动态绑定，最终输出的是子类student中的show})。方法形参为父类，可以传参时传入子类，调用参数的方法时会用到多态</li><li>Instanceof操作符: <code>x instanceof A</code>:检验对象x是否是类A的对象，返回值为boolean(若x instanceof A为true,x instanceof A的父类,也为true)</li><li>==: 基本类型比较是值等则为true，引用类型比较则是指向同一个对象才返回true；equals()当比较例如String类是比较String的值相同则为true，而不是比较是否指向同一个对象</li><li>包装类: <code>boolean b=new Boolean(“true”)</code>这是自动拆箱，<code>Boolean b=true</code>这是自动装箱，都是在JDK1.5后支持。包装类方便基本类型与字符串的转换</li><li><code>System.out.println(x)//若X是对象</code>，则相当于输出<code>x.toString()</code>.</li><li>用static修饰的方法和变量可以直接用(类名.方法)调用，随着类的加载而加载，被所有对象共享</li><li>单例模式: 用static创建变量，进行一次实例化，共同使用，分为1.饿汉式 2.懒汉式(两者区别，饿汉式在类实例化时就创建，懒汉式在调用<code>getInstance()</code>方法时才创建)</li><li>代码块先于构造器初始化,静态代码块值执行一次</li><li>匿名内部类用于隐式继承父类或实现接口，可以在匿名内部类中用代码块初始化</li><li><code>final</code>修饰的类不能被继承，<code>final</code>修饰的变量不能被修改且必须显示赋值，<code>final</code>饰的方法不能被子类重写</li></ol><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><ol start="22"><li>Abstract修饰抽象方法和抽象类，抽象类不能实例化，但可以由构造器，继承抽象类的子类必须重写抽象类中的抽象方法，抽象方法是只有声明没有实现。若某类中有抽象方法，则该类必须声明为抽象类</li><li>模板设计模式: 定义一个抽象类，定义一个抽象类，子类继承抽象类，可以直接使用而不用重写部分已经写好的通用方法。</li><li>接口与抽象类的区别:</li></ol><ul><li>接口中（默认<code>public abstract</code>） 只能声明方法而不能实现方法2.接口中的变量只能是<code>public static final</code>类型的</li><li>接口不能含有静态代码块、静态方法以及构造器 4.一个类只能继承一个抽象类，但是却可以实现多个接口</li></ul><ol start="25"><li>工厂模式:</li></ol><ul><li>定义接口，将实现同一接口的不同类放入工厂，并延迟到子类再决定实例化哪一个类。  </li><li>定义一个产品接口 2.创建多个实现接口的不同实体类</li><li>创建一个工厂，基于开发者对实体类的需求返回类</li></ul><ol start="26"><li>内部类也是类，但特殊点在若内部类是<code>static</code>修饰，就不能使用外部类的非static的成员变量。而非static的内部类中的成员不能声明为static（内部类主要用来解决JAVA不能多层继承的问题）</li><li>异常问题，子类不能抛出比父类更大范围的异常</li><li>Java分为三大集合:</li></ol><ul><li>Set,Map,List</li><li><code>set和list</code>使用<code>iterator</code>或者foreach迭代</li></ul><ol start="29"><li><code>treeSet</code>有序，<code>treeMap</code>有序</li><li>Map使用keySet或者entrySet遍历</li><li>Collections工具</li></ol><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><ol start="32"><li>泛型:</li></ol><ul><li>泛型类；</li><li>泛型接口: 实现泛型接口时如果不具体指定类型，则实现类也需要加上泛型（例如<code>class A&lt;T&gt; implements interface&lt;T&gt;</code>）；</li><li>泛型方法: <code>public &lt;T&gt; void test(T t){}</code>在静态方法中不能使用类定义泛型，若需要使用，只能使用静态方法自己定义的泛型<code>public static &lt;T&gt; void test(T t){}</code></li></ul><ol start="33"><li>通配符是“？”:</li></ol><ul><li><code>&lt;? extends Person&gt;</code>表示通配只接受Person及其子类的引用</li><li><code>&lt;? super Person&gt;</code>表示通配只接受Person及其父类的引用</li><li><code>&lt;？Extends Comparable&gt;</code>表示通配只接受实现<code>Comparable接口</code>的类的引用</li></ul><ol start="34"><li>枚举类:<br><code>Season summer = Season.SUMMER;Summer.showInfo();</code><br>每个枚举都是单例模式</li><li>注解: 编写注解需要使用@interface声明，在注解前面也需要加其他注解来限制编写的注解的作用范围</li><li>文件流: File类: 其中，<code>File.separator</code>为当前系统分隔符，File只能操作文件本身，比如删除文件，但不能改变文件的内容</li><li>文件流: <code>FileOutputStream</code>输出流（字节流），将数据输出到某文件，<code>FileInputStream</code>输入流（字节流），从某文件中获取数据输入（可用byte数组存储）。<code>FileReader</code>输入流（字符流，可以char数组存储）</li><li>缓冲流: 先将数据放入内存中，再在内存中操作数据，提升性能。<code>BufferedInputStream</code>和<code>BufferedOutputStream</code></li><li>转换流: <code>InputStreamReader</code>等等。。不同文本格式的转换，比如GBK到UTB-8</li><li>标准输入输出流</li><li>对象流: 序列化和反序列化（包名，类名等要完全一致）</li><li>反射机制: 前提是JVM已经加载过这个类</li></ol><ul><li>反射机制中的Class代表该字节码文件，Class类是JVM创建的表示类信息的类，而Object是所有类的父类，可以利用<code>Class.class.isAssignableFrom(Object.class)</code>来判断子类父类关系</li><li>可以利用反射机制调用类的私有方法和私有变量（这类操作会破坏类的封装性）</li></ul><ol start="43"><li>Java动态代理: 当需要修改方法执行前或执行后的操作时，利用动态代理可以简化操作，想要通过<code>Proxy.newProxyInstance</code>方法被代理则此对象的类需要实现接口<br>JDK实现:</li></ol><ul><li>自己定义的接口 </li><li>实现这个接口 </li><li>实现<code>InvocationHandler</code>接口</li><li>利用第三步中的类获取代理类，调用方法（JVM会自动生成Proxy类文件，调用InvocationHandler接口中实现Invoke方法达到最终目的）</li></ul><ol start="44"><li>Java静态代理和动态代理讲解:</li></ol><ul><li><a href="https://www.jianshu.com/p/9bcac608c714" target="_blank" rel="noopener">https://www.jianshu.com/p/9bcac608c714</a></li><li><a href="https://www.bilibili.com/video/av63885236" target="_blank" rel="noopener">https://www.bilibili.com/video/av63885236</a></li></ul><ol start="45"><li>创建线程:</li></ol><ul><li>继承<code>thread</code>类  </li><li>实现<code>Runnable</code>接口</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>博客测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/25/hello-world/"/>
    <url>/2020/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
