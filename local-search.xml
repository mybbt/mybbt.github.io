<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《Essential C++》</title>
    <link href="/2020/06/13/%E3%80%8AEssential%20C++%E3%80%8B/"/>
    <url>/2020/06/13/%E3%80%8AEssential%20C++%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>构造函数语法初始化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num(0); &#x2F;&#x2F; int num &#x3D; 0</span><br><span class="line">complex&lt;double&gt; purei(0,7);</span><br></pre></td></tr></table></figure>单一值赋值可以使用“<strong>=</strong>” ，而当赋值复数时则需要同时设置实数和虚数两个值，所以需要使用构造函数语法初始化</li><li>vector可以依次赋值或者直接通过已有数组赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 依次赋值</span><br><span class="line">vector&lt;int&gt; elem_seq(2);</span><br><span class="line">elem_seq[0] &#x3D; 0;</span><br><span class="line">elem_seq[1] &#x3D; 1;</span><br><span class="line">......</span><br><span class="line">&#x2F;&#x2F; 已有数组赋值</span><br><span class="line">int elem_vals[2] &#x3D; &#123;0,1&#125;;</span><br><span class="line">vector&lt;int&gt; elem_seq(elem_vals,elem_vals+2);</span><br></pre></td></tr></table></figure></li></ol><ul><li>贴个博客：<a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" rel="noopener">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</a></li><li>vector几种初始化方式：<a href="https://blog.csdn.net/weixin_42380203/article/details/80706422" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42380203/article/details/80706422</a></li></ul><ol start="3"><li>使用指针寻址时，一定要先判断指针是否为空指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;判断方式</span><br><span class="line">int *pv &#x3D; 0;&#x2F;&#x2F;此时的0是地址，代表 pv 为null指针</span><br><span class="line">if(pv)</span><br><span class="line">cout&lt;&lt;&quot;不为空&quot;;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;为空&quot;;</span><br></pre></td></tr></table></figure></li><li><code>setw()</code>用来控制字符宽度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;iomanip&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">string mess;</span><br><span class="line">cout&lt;&lt;setw(5)&lt;&lt;&quot;a&quot;； &#x2F;&#x2F;结果是4个空格加上一个 a</span><br><span class="line">cin&gt;&gt;setw(5)&gt;&gt;mess; &#x2F;&#x2F;限制输入字符宽度为5，或者理解为限制输入字符长度不大于5</span><br></pre></td></tr></table></figure></li></ol><ul><li>贴个博客：<a href="https://blog.csdn.net/weixin_43838785/article/details/92401461" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43838785/article/details/92401461</a></li><li>针对上个博客解释：setw(5)只显示了abcd四个字母是因为char数组中最后一个位置存放的是终止符(‘\0’)，实际是abcd四个字符加上一个终止符(‘\0’),共占5个字符位</li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol start="5"><li>void test(int)和void test(int &amp;)的区别是前者会创建副本，并不影响原有变量，后者传入变量本身，会影响原有变量（前者为传值，后者为传址）</li></ol><ul><li>引用有两个好处：第一，可以直接对传入对象修改；第二，可以降低复制大型对象的额外负担</li></ul><ol start="6"><li>指针和引用的区别：第一，指针使用箭头成员选择运算符(-&gt;)，引用则使用点成员选择运算符(.)；第二，指针即可能指向某个实际对象，也可能不指向某个实际对象，使用前需要判断其值非零，而引用则必定代表某个对象，不需要检查<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指针</span><br><span class="line">void display(const vector&lt;int&gt; *vec)</span><br><span class="line">&#123;</span><br><span class="line">if(!vec)&#x2F;&#x2F;此时vec为零，代表指针为空，不指向实际对象</span><br><span class="line">return;</span><br><span class="line">for(int ix &#x3D; 0;ix &lt; vec-&gt;size();ix++)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;输出值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;引用</span><br><span class="line">void display(const vector&lt;int&gt; &amp;vec)</span><br><span class="line">&#123;</span><br><span class="line">for(int ix &#x3D; 0; ix &lt; vec.size();ix++)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;输出值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>声明局部对象时，若以指针或者引用形式返回都是错误的，因为在函数执行完成后，局部对象将不复存在。而将对象以传值方式返回，则不会出错，因为返回的是对象的副本，在函数之外仍然存在。（name return value）NRV优化，深入解释见[LIPPMAN98]的14.8节。</li><li>使用new分配堆内存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int *pi;</span><br><span class="line">&#x2F;&#x2F;第一种方式，从堆中分配一个类型为int的对象，再将其地址赋值给pi</span><br><span class="line">pi &#x3D; new int;</span><br><span class="line">&#x2F;&#x2F;第二种方式，在第一种方式的基础上初始化int对象的值</span><br><span class="line">pi &#x3D; new int(1024);</span><br><span class="line">&#x2F;&#x2F;第三种方式，分配数组，但是无法直接初始化值</span><br><span class="line">pi &#x3D; new int[10];</span><br><span class="line">&#x2F;&#x2F;释放堆内存，如果不释放则会导致内存泄漏(memory leak)</span><br><span class="line">delete pi;&#x2F;&#x2F;此处编译器会自动进行if(pi !&#x3D; 0)的检测，无需手动检查</span><br><span class="line">&#x2F;&#x2F;释放数组形式的堆内存</span><br><span class="line">delete []pi;</span><br></pre></td></tr></table></figure></li><li>设置默认参数值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort(ofstream &amp;os &#x3D; cout)&#x2F;&#x2F;用户不指定，则默认使用cout输出</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>默认参数值设置有两个规则：第一，默认参数解析从右边开始，若某个参数设置了默认值，则它的右边所有参数都需要设置默认值；第二，默认参数值只能设置一次，可以在函数声明处设置，也可以在函数定义处设置，但是只能在两个地方二选一(书中推荐在函数声明处设置)</li><li>静态局部对象，作用域与局部对象相同，不同之处在于静态局部对象的生命期贯穿整个程序运行期间，存储在静态存储区</li><li>函数指针，必须指明函数返回类型以及参数列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数声明</span><br><span class="line">const vector&lt;int&gt; *fibon_seq(int);</span><br><span class="line">const vector&lt;int&gt; *lucas_seq(int);</span><br><span class="line">const vector&lt;int&gt; *pell_seq(int);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">seq(1,fibon_seq);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;函数定义</span><br><span class="line">bool seq_elem(int pos,const vector&lt;int&gt;* (*seq_ptr)(int))&#x2F;&#x2F;函数指针</span><br><span class="line">&#123;</span><br><span class="line">const vector&lt;int&gt; *pseq &#x3D; seq_ptr(pos);</span><br><span class="line">&#x2F;&#x2F;一系列操作</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;............</span><br></pre></td></tr></table></figure></li><li>头文件中一般只放函数声明，不放入函数定义，满足定义一次的规则，但是有两个例外；第一个例外是inline关键字修饰的函数(解释见如下两个博客);第二个例外是const关键字修饰的对象，只在当前文件下可见,所以可以在多个程序代码文件中再次定义</li></ol><ul><li>贴个关于头文件中inline关键字的博客：<a href="https://blog.csdn.net/chenlei0630/article/details/45720913javascript" target="_blank" rel="noopener">https://blog.csdn.net/chenlei0630/article/details/45720913javascript</a>:;</li><li>再贴个博客：<a href="https://blog.csdn.net/Ronnie_Hu/article/details/62238311" target="_blank" rel="noopener">https://blog.csdn.net/Ronnie_Hu/article/details/62238311</a></li></ul><ol start="13"><li>使用双引号引用文件默认在当前文件同一目录下寻找，使用尖括号引用文件则默认路径寻找（不一定在文件同一目录下）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt; &#x2F;&#x2F;默认路径下寻找</span><br><span class="line">#include&quot;million.h&quot; &#x2F;&#x2F;当前文件路径下寻找</span><br></pre></td></tr></table></figure></li><li>关于extern关键字及部分相关关键字的解释：<a href="https://www.cnblogs.com/yuxingli/p/7821102.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuxingli/p/7821102.html</a></li></ol><ul><li>贴个博客：<a href="https://blog.csdn.net/fengbingchun/article/details/78941738" target="_blank" rel="noopener">https://blog.csdn.net/fengbingchun/article/details/78941738</a></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol start="15"><li>Iterator部分语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;iter指向一个vector,vector中的元素类型为string</span><br><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">vector&lt;string&gt;::iterator iter&#x3D;svec.begin();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Iterator与const vector的应用</span><br><span class="line">const vector&lt;string&gt; cs_vec;</span><br><span class="line">vector&lt;string&gt;::const_iterator iter&#x3D;cs_vec.begin();</span><br><span class="line">&#x2F;&#x2F;iter-&gt;size()</span><br></pre></td></tr></table></figure></li><li>vector和list是顺序性容器，vector类似数组，分配连续的内存，可随机访问；list类似指针，插入和删除效率高；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; slist;</span><br><span class="line">list&lt;string&gt;::iterator it1&#x3D;find(slist.begin(),slist.end(),str);</span><br><span class="line">list&lt;string&gt;::iterator it2&#x3D;find(slist.begin(),slist.end(),val);</span><br><span class="line">&#x2F;&#x2F; list不支持iterator的偏移运算，如右所示：slist.erase(it1,it1+num)，错误操作;</span><br><span class="line">slist.erase(it1,it2);&#x2F;&#x2F;正确操作</span><br></pre></td></tr></table></figure></li><li>map数据三种查询方式：</li></ol><ul><li>索引，但是会自动将不存在的key加入map</li><li>find()函数，存在会返回一个iterator，指向key/value形成的一个pair(pair <strong>class</strong>是标准库的一员，不存在则返回end()</li><li>count()函数，返回某个特性项在map内的个数</li></ul><ol start="18"><li>关于单冒号和双冒号的作用，如下博客</li></ol><ul><li><a href="https://blog.csdn.net/android_lover2014/article/details/54946261" target="_blank" rel="noopener">https://blog.csdn.net/android_lover2014/article/details/54946261</a></li></ul><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol start="19"><li>定义在类主体内的<strong>member function</strong>会被自动视为inline函数</li><li>类构造函数初始化</li></ol><ul><li>第一种是利用参数赋值</li><li>第二种是成员初始化列表，如下所示<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下是伪代码，实际代码见书P106</span><br><span class="line">class Triangular;</span><br><span class="line">Triangular::Triangular(const Triangular &amp;rhs):_length(rhs.length),_beg(rhs._beg)&#123;&#125;&#x2F;&#x2F;大括号内是空的；这种赋值方式等同于第一种</span><br></pre></td></tr></table></figure></li></ul><ol start="21"><li>在将一个class object赋予另一个object时，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Triangular tr1(8);</span><br><span class="line">Triangular tr2 &#x3D; tr1;</span><br></pre></td></tr></table></figure>class data member会被依次赋值，即成员逐一初始化(memberwise initialization)，此时若tr1中存在指针，那么tr1中的指针也会放入tr2中，当tr2先进行析构释放数组空间，则tr1中的指针就将对已经释放的空间进行操作，这是一种严重错误。若成员逐一初始化会影响程序，那么就改变默认行为，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Triangular::Triangular(const Triangular&amp; t) : _size(t._size)</span><br><span class="line">&#123;</span><br><span class="line">pmat &#x3D; new double[_size];</span><br><span class="line">&#x2F;&#x2F; 重新new一个数组</span><br><span class="line">&#x2F;&#x2F; 然后可以利用for循环依次赋值到新的数组，这样在释放数组空间时，不会影响到原有的数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>另外的改变方式则是使用操作符重载</li><li>书中P110讲解了使用const保证member function不修改变量值，使用时跟在参数列表之后，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Triangular</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;const member function</span><br><span class="line">int length()  const &#123;return _length;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; non-const member function</span><br><span class="line">bool next(int &amp;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>编译器会根据const检查函数是否修改变量值，以下是书中P111提到的问题(以下是伪代码，源代码见书)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class val_class</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">BigClass &amp;val() const &#123;return _val;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">BigClass _val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>以上代码中使用了const修饰member function，但是返回的是一个non-const reference指向 _val，这会产生问题，让程序可以在其他地方修改_val，如下是修正后代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class val_class</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F; 使用重载满足两种需求</span><br><span class="line">const BigClass &amp;val() const &#123;return _val;&#125;</span><br><span class="line">BigClass &amp;val() &#123;return _val;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">BigClass _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void example(const BigClass *pbc, BigClass &amp;rbc)</span><br><span class="line">&#123;</span><br><span class="line">pbc-&gt;val(); &#x2F;&#x2F; const版本</span><br><span class="line">rbc.val(); &#x2F;&#x2F; non-const版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>mutable关键字表示了对该变量的修改不会破坏class object的常量性，一般在针对在const member function中 可变的变量 使用</li><li>this指针在成员函数中用来指向其调用者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码</span><br><span class="line">Triangular tr1;</span><br><span class="line">tr1.copy(tr2); &#x2F;&#x2F; copy(tr1,tr2)，注释含义见书P114</span><br><span class="line"></span><br><span class="line">Triangular&amp; Triangular::copy(const Triangular &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; C++中的this很类似于 Java中的this</span><br><span class="line">if(this !&#x3D; rhs)</span><br><span class="line">&#123;</span><br><span class="line">_length &#x3D; rhs._length;&#x2F;&#x2F; 相当于this._length &#x3D; rhs._length</span><br><span class="line">&#125;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态成员变量可以被同一类的所有对象访问，通过<strong>类名::变量名</strong>的方式访问(这个变量名是静态成员变量的名字)，但是私有的静态成员变量不可以直接访问</li><li>静态成员函数不能访问非静态成员变量，在类中声明的静态成员函数，在类的主体外部定义时无须重复使用static定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Triangular</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">static void gen_elems_to_value(int value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Triangular::gen_elems_to_value(int value) &#x2F;&#x2F;此处定义就无须再加上static声明了</span><br><span class="line">&#123; &#x2F;&#x2F; 定义 &#125;</span><br></pre></td></tr></table></figure></li><li>运算符重载除了四个运算符，其他都可重载，重载运算符不能改变操作数，不能改变优先级<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 伪代码，源代码见书P119</span><br><span class="line">class Triangular_iterator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">bool operator&#x3D;&#x3D;(const Triangular_iterator&amp; ) const;</span><br><span class="line">Triangular_iterator&amp; operator++(); &#x2F;&#x2F; 前置版</span><br><span class="line">Triangular_iterator operator++(int); &#x2F;&#x2F; 后置版，由于重载规则要求参数列表不同，所以参数列表中放入int类型参数，而实际用不上</span><br><span class="line">private:</span><br><span class="line">int _index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline bool Triangular_iterator::operator&#x3D;&#x3D;(const Triangular_iterator&amp; rhs) const</span><br><span class="line">&#123; return _index&#x3D;&#x3D;rhs._index;&#125;</span><br><span class="line"></span><br><span class="line">inline Triangular_iterator&amp; Triangular_iterator::operator++() &#x2F;&#x2F; 前置递增版</span><br><span class="line">&#123;</span><br><span class="line">++_index;</span><br><span class="line">&#x2F;&#x2F; 需要检查，节约界面就不写了</span><br><span class="line">&#125;</span><br><span class="line">inline Triangular_iterator&amp; Triangular_iterator::operator++(int) &#x2F;&#x2F; 后置递增版，这里的int参数，编译器会自动产生值，值为0</span><br><span class="line">｛</span><br><span class="line">Triangular_iterator tmp &#x3D; *this;</span><br><span class="line">++_index;</span><br><span class="line">&#x2F;&#x2F; 检查</span><br><span class="line">return tmp;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li><li>在类中可以使用typedef简化名称 [嵌套类型(Nested Type)]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下都是伪代码</span><br><span class="line">&#x2F;&#x2F; typedef existing_type new_name</span><br><span class="line">class Triangular｛</span><br><span class="line"></span><br><span class="line">typedef Triangular_iterator iterator; &#x2F;&#x2F; 主角出场</span><br><span class="line"></span><br><span class="line">Triangular_iterator begin() const</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; return.....</span><br><span class="line">&#125;</span><br><span class="line">｝;</span><br><span class="line"></span><br><span class="line">Triangular::iterator it &#x3D; train.begin();</span><br></pre></td></tr></table></figure></li><li><strong>friend</strong>关键字可以使得被修饰对象具有与class member function相同的访问权限(比如可以访问私有的变量或函数)，类中虽然有友元声明，但是友元函数并不是成员函数</li></ol><ul><li>贴个教程：<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-friend-functions.html</a></li></ul><ol start="30"><li>指向<strong>成员函数(member function)</strong>的指针<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (num_sequence::*pm)(int) &#x3D; 0; &#x2F;&#x2F; pm是一个指针，指向num_sequence的成员函数，成员函数的返回类型为void，并且只接受一个int型参数，如右所示，初始化值为0，表示不指向任何成员函数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 简化版本</span><br><span class="line">typedef void (num_sequence::*PtrType)(int);</span><br><span class="line">PtrType pm &#x3D; 0;</span><br></pre></td></tr></table></figure>接上，实际使用Pointer to member function，<strong>.*</strong>是个pointer to member selection运算符，(对象名<strong>.*</strong>指针名)(参数)，例子如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Stack&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef void (Stack::*pm)(int);</span><br><span class="line">    Stack()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;initialize&quot;&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Stack()&#123;std::cout&lt;&lt;&quot;end&quot;&lt;&lt;std::endl;&#125;</span><br><span class="line">    void get(int);</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Stack c;</span><br><span class="line">    Stack::pm pp &#x3D; Stack::get;</span><br><span class="line">    (c.*pp)(3); &#x2F;&#x2F; (对象名*.*指针名)(参数)</span><br><span class="line">&#125;</span><br><span class="line">void Stack::get(int c)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt; c &lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>maximal munch规则：每个符号序列总是以合法符号序列中最长的那个解释，如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt; seq; &#x2F;&#x2F; 正确</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; seq; &#x2F;&#x2F; 错误，由于 &quot;&lt;&lt;&quot; 是合法符号序列，若两个&quot;&lt;&quot;之间不留空，根据规则，则会被看待为&quot;&lt;&lt;&quot;</span><br><span class="line">a+++p &#x2F;&#x2F; 经典问题，根据以上规则，它会被解释为 a++ + p</span><br></pre></td></tr></table></figure></li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol start="32"><li>多态：让基类的指针或引用得以透明的指向其任何一个派生类的对象<br>动态绑定：根据所属实际类调用不同派生类的同名函数，在执行时判定<br>静态绑定：在执行前判定</li><li>virtual关键字，可以让成员函数在运行时动态解析，静态成员函数无法被virtual修饰</li><li>访问层级：</li></ol><ul><li>public：公开，所有类都能访问</li><li>protected：受保护的，只有派生类能访问</li><li>private：只有基类自己可以访问</li></ul><ol start="35"><li>纯虚函数，由于其接口的不完整性，程序无法为它产生对象，这种只能作为派生类的子对象使用，前提是派生类提供了定义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 纯虚函数</span><br><span class="line">class num_sequence&#123;</span><br><span class="line">virtual int  elem(int pos) const &#x3D; 0; &#x2F;&#x2F; int elem(int pos) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>根据规则，如果基类定义中存在虚函数，一般会将析构函数也定义为虚函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class num_sequence&#123;</span><br><span class="line">public:</span><br><span class="line">virtual ~num_sequence();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">num_sequence *ps &#x3D; new Fibonacci(12);</span><br><span class="line">delete ps;</span><br></pre></td></tr></table></figure>ps是基于基类的指针，但是实际上是指向派生类Fibonacci的对象，而非虚函数在编译时就完成了解析，只能规矩被调用时的类型判断，而无法根据实际情况调用析构函数，所以……</li><li>派生类中的构造器不仅能给自己初始化，也可以对基类初始化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Stack&#123;</span><br><span class="line">public:</span><br><span class="line">    Stack(int a)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;initialize a: &quot;&lt;&lt;a&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Test: public Stack&#123;</span><br><span class="line">    public:</span><br><span class="line">        Test(int a,int b):Stack(a)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;&quot;Test: &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>typeid运算符，这是运行时类型鉴定机制(RTTI)，它会返回一个type_info对象，其中存储着与类型相关的种种信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;typeidinfo&gt;</span><br><span class="line">inline const char* num_sequence::what_am_i() const &#123;return typeid(*this).name();&#125;</span><br><span class="line">&#x2F;&#x2F; 另一种用法</span><br><span class="line">num_sequence *ps&#x3D;&amp;fib;</span><br><span class="line">if(typeid(*ps)&#x3D;&#x3D;typeid(Fibonacci));</span><br></pre></td></tr></table></figure></li><li>static_cast类型强制转换，但是没有验证机制，dynamic_cast也是强制转换，但是有验证机制，更加安全<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  static_cast</span><br><span class="line">if(typeid(*ps)&#x3D;&#x3D;typeid(Fibonacci))</span><br><span class="line">&#123;</span><br><span class="line">Fibonacci *pf &#x3D; static_cast&lt;Fibonacci*&gt;(ps);</span><br><span class="line">pf-&gt;gen_elem(64);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  dynamic_cast</span><br><span class="line">if(Fibonacci(*pf)&#x3D;dynamic_cast&lt;Fibonacci*&gt;(ps))</span><br><span class="line">pf-&gt;gen_elem(64);</span><br></pre></td></tr></table></figure></li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>无</p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol start="40"><li>抛出异常和捕获异常：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int test()</span><br><span class="line">&#123;</span><br><span class="line">if(!exist)</span><br><span class="line">throw &quot;no exist&quot;;</span><br><span class="line">else</span><br><span class="line">throw 42;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下面的函数将捕获上面test中抛出的异常，根据异常类型与catch比较</span><br><span class="line">bool some_function()</span><br><span class="line">&#123;</span><br><span class="line">bool status &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  throw 42</span><br><span class="line">catch(int errno)&#123;</span><br><span class="line">&#x2F;&#x2F; 处理</span><br><span class="line">status &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  throw &quot;no exist&quot;</span><br><span class="line">catch(const char* errno)&#123;</span><br><span class="line">&#x2F;&#x2F; 处理</span><br><span class="line">status &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在catch中可以只写throw，后面不跟参数，这样将会再次抛出，寻找其他catch；还可以使用<strong>catch(…)</strong>方式，这将会捕获任何异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">catch(int errno)&#123;</span><br><span class="line">&#x2F;&#x2F; 处理</span><br><span class="line">throw; &#x2F;&#x2F;再次抛出</span><br><span class="line">&#125;</span><br><span class="line">catch(...)｛ &#x2F;&#x2F; catch-all 方式，捕获任何异常</span><br><span class="line">&#x2F;&#x2F; 处理</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></li><li>try-catch异常处理，当try块发生异常，但没有相应的catch子句将它捕获，此函数便会中断，由异常处理机制接管，沿着函数调用链回溯，如果一直回溯到main()还是无法找到，那么将会调用标准库提供的处理函数</li><li>如果不想抛出异常，则可以用如下方式编写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; *p&#x3D;0;</span><br><span class="line">p &#x3D; new (nothrow) vector&lt;string&gt;; &#x2F;&#x2F; 如果没有足够的空间分配，则会赋值 p&#x3D;0，所以如果不抛出，则使用时要检查 p!&#x3D;0</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web服务器</title>
    <link href="/2020/04/10/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/04/10/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<ol><li><p>模仿Tomcat实现的一个非常简陋的Web服务器</p></li><li><p>参考资料以及代码来源: 《深入剖析Tomcat》</p></li><li><p>源码地址: <a href="https://github.com/mybbt/HowTomcatWorks" target="_blank" rel="noopener">https://github.com/mybbt/HowTomcatWorks</a></p></li><li><p>笔记都穿插在源码注释以及每章节的Readme文件中</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Spring实战》笔记</title>
    <link href="/2020/03/19/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/19/%E3%80%8ASpring%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>书籍版本是第四版</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>Spring变迁历史以及整体概览</li><li>通过构造器和接口可以实现依赖注入</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol start="3"><li>创建对象之间协作关系的行为通常称为装配，这也是依赖注入的本质</li><li>Spring主要提供了三种装配方式：</li></ol><ul><li>在XML中进行显式配置</li><li>在Java中进行显式配置</li><li>隐式的bean发现机制和自动装配</li></ul><ol start="5"><li><code>@ComponentScan</code>默认扫描配置类相同的包下带有<code>@Component</code>的类；在XML中有类似的功能，<code>&lt;context:component-scan base-package=&#39;...&#39;&gt;</code>可以启动此功能</li><li>需要<code>spring-test</code>,<code>spring-context</code>,<code>junit</code>三个jar包，在使用maven导包时多导入了<code>spring-web</code>的jar包运行就一直报错，删除这个jar包就可以正常运行(文章2.2.1笔记)</li><li><code>@RunWith(SpringJUnit4ClassRunner.class)</code>注解用来在测试开始时自动创建Spring应用上下文<br><code>@ContextConfiguration(classes = CDConfig.class)</code>注解用来表示在什么地方加载配置，示例中表示在CDConfig中加载配置，CDConfig是一个包含有<code>@ComponentScan</code>注解的类</li><li><code>@Autowired</code>和<code>@Inject</code>大多数情况可以相互替换，前者来自Spring，后者来自Java依赖注入规范</li><li><code>@Bean</code>+<code>@Configuration</code>在Java中可以用来替代XML配置bean</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol start="10"><li>使用<code>@profile</code>可以简化不同环境的配置，通过spring.profiles.active和spring.profiles.default来激活profile，active的优先级高于default；如果active和default都不存在，则没有激活的profile，因此只会创造那些没有定义在profile的bean</li><li><code>@profile</code>利用<code>@Conditional</code>来实现不同条件下配置的选择</li><li><code>@Qualifier</code>可以用来将bean设置为首选项来消除歧义，当具有多个<code>@Primary</code>时，可以使用<code>@Qualifier</code>指定具体的bean；<code>@Qualifier</code>既可以在注入点定义，也可以在bean定义的地方使用(类似于取一个别名)</li><li><code>@Scope</code>用来声明bean的作用域，默认是Singleton(单例)，其中还有代理模式可以处理不同作用域的交互</li></ol><ul><li>单例(Singleton)：在整个应用中，只对bean实例化一次</li><li>原型(Prototype)：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例</li><li>会话(Session)：每次会话都创建一个bean实例</li><li>请求(Request)：每次请求都创建一个bean实例</li></ul><ol start="14"><li>SpEL表达式</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol start="15"><li>横切关注点就是散布于应用中的各种功能，而将这些功能与业务逻辑解耦就是AOP所实现的 <img src="/img/blogpic/aop.jpg" alt="avatar"></li><li>AOP术语：</li></ol><ul><li>通知(Advice)：    定义了切面是什么以及何时执行</li><li>连接点(Join point)：执行过程中可以应用通知的点</li><li>切点(Pointcut)：应用特定通知的连接点</li><li>切面(Aspect)：通知+切点</li><li>引入(Introduction)：向现有类添加新方法或属性，并无需修改现有类</li><li>织入(Weaving)：把切面应用到目标对象并生成新的代理对象的过程</li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol start="17"><li>除了Web.xml配置DispatcherServler，还可以通过继承<code>AbstractAnnotationConfigDispatcherServletInitializer</code>自动配置DispatcherServlet和Spring应用上下文(需要Servlet3.0)</li><li>MockMvc可以用来测试web项目</li></ol><ul><li>在idea中手动创建Lib并导入jar包，jar包版本需要相同(同一个类可能存在不同jar包中，这些jar彼此之间版本不同，所以会冲突)，否则可能会报错java.lang.NoSuchMethodError(在使用MockMvc时发现的错误)</li><li>若是idea，还需要在项目 Facets中修改 Web resource Directory为webapp(这是我的文件命名，根据自己的文件命名修改)</li><li>使用实现AbstractAnnotationConfigDispatcherServletInitializer来自动配置DispatcherServler，可以删除web.xml文件，同时命名约束要注意，不同包可能有类似约束容易混淆</li></ul><ol start="19"><li>需要区分运行时常量和编译时常量，@RequestParam中的默认值需要的编译时常量，若用 Long.String(Long.MAX_VALUE) 则是运行时常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static final String MAX_LONG_AS_STRING &#x3D; Long.MAX_VALUE+&quot;&quot;;&#x2F;&#x2F;若是MAX_LONG_AS_STRING &#x3D; Long.String(Long.MAX_VALUE)就会报错</span><br><span class="line">&#x2F;&#x2F;报错内容为 Attribute value must be constant</span><br><span class="line">    @RequestMapping(method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Spittle&gt; spittles(</span><br><span class="line">            @RequestParam(value &#x3D; &quot;max&quot;, defaultValue &#x3D; MAX_LONG_AS_STRING)long max,</span><br><span class="line">            @RequestParam(value &#x3D; &quot;count&quot;,defaultValue &#x3D; &quot;20&quot;)int count)&#123;</span><br><span class="line">        return spittleRepository.findSpittles(max, count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol start="20"><li>渲染Web视图(JSP, Apache Tiles, Thymeleaf)</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol start="21"><li>文件处理和异常处理</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol start="22"><li>Spring Web Flow是SpringMVC的扩展框架，支持开发基于流程的应用程序</li><li>其余章节跳过</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis笔记</title>
    <link href="/2020/03/06/MyBatis%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/06/MyBatis%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>MyBatis是一款针对数据库的持久层框架，它避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的<code>XML</code>或<code>注解</code>来配置和映射原生类型、接口和 POJO（Plain Ordinary Java Objects，简单的 Java 对象）为数据库中的记录</li><li>导入MySQL的jar是5.1.47版本的</li><li>MyBatis问题解决: </li></ol><ul><li><img src="/img/blogpic/mybatis.jpg" alt="avatar">图中在try-catch中用<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>再次创建了新的变量而覆盖了开始声明的变量；但是这个变量在try-catch中，出了try-catch就不再存在了，而<code>private static SqlSessionFactory sqlSessionFactory = null;</code>已经声明了这个变量，所以最后返回值出了问题；将<code>SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code>改为<code>sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></li></ul><p><strong>如图</strong><img src="/img/blogpic/mybatis1.jpg" alt="avatar"></p><ul><li>上面的问题小结: 在try-catch中new的对象在try-catch外的范围不能使用；而上图中误将已经声明的变量在try-catch中再重新声明了一次，所以最后的返回值是null，而不是try-catch中读取的XML文件</li><li>执行时找不到UserDao的UserMapper的配置文件，在maven中如下配置  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>但是出现这种问题的原因不知道，有待查询；先把mybatis跑起来再说</li><li>贴个博客: <a href="https://www.cnblogs.com/aflyun/p/6780117.html" target="_blank" rel="noopener">https://www.cnblogs.com/aflyun/p/6780117.html</a></li></ul><ol start="4"><li><pre><code>&lt;mapper namespace=&quot;com.my.dao.UserDao&quot;&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.my.pojo.User&quot;&gt;     select * from wo&lt;/select&gt;&lt;/mapper&gt;</code></pre>id是namespace指定的类中的方法名</li><li>特殊方法; 使用Map方法的键值对，匹配SQL语句中的查询字段；<code>#{字段名}</code>中的字段名只需要和Map中的键对应，而不用创建单独的类文件来与属性名对应，比较万能，但是非标准(这里解释得比较模糊，想得起来就用，想不起来就老老实实单独写个类对应XML文件中的字段)</li><li>当properties配置文件和properties的属性值冲突时，以外部配置文件的值为准</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="7"><li>Java实体类中的属性名需要与数据库字段名相同(这是在网上视频中提出的问题，我在自己的环境下测试int型字段不受影响，String类型的变量会受到这种影响)</li><li>项目简单或者SQL语句不复杂可以使用注解简化操作，但是更多情况是使用XML配置文件</li><li>MyBatis有些类似<code>&lt;where&gt;</code>的标签，在动态SQL文档中可以找到具体介绍</li><li>MyBatis缓存有一级缓存和二级缓存,缓存的存在是为了优化性能</li></ol><ul><li>一级缓存即本地的会话缓存，可以使用SqlSession测试或者清除，它仅仅对一个会话汇总的数据进行缓存</li><li>二级缓存即全局缓存，一级缓存会被提升到二级缓存，作用域扩大(大概意思是这样，不太严谨)，接下来贴个官方文档的解释: <code>二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新</code></li><li>缓存查询顺序，惯例贴个博客: <a href="https://www.cnblogs.com/yanl55555/p/11936765.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanl55555/p/11936765.html</a></li><li>再贴个博客：<a href="https://blog.csdn.net/jinhaijing/article/details/84257981" target="_blank" rel="noopener">https://blog.csdn.net/jinhaijing/article/details/84257981</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC笔记</title>
    <link href="/2020/03/04/SpringMVC%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/04/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>SpringMVC是一种基于Java实现的Web框架：Model(模型层) + View(视图层) + Controller(控制层)</li><li><code>/</code>和<code>/*</code>和<code>/**</code>：可以使用前端控制器测试，<code>/</code>不会拦截例如带.jsp后缀的文件，而<code>/*</code>会拦截所有文件，包括带.jsp后缀的文件(个人猜想: <code>/</code>匹配规则是文件夹匹配，而<code>/*</code>是贪婪匹配，文件夹和文件都匹配),<code>/**</code>拦截文件夹和子文件夹</li><li><code>classpath:</code>和<code>classpth*:</code>: 不带星号的只在classpath只在第一个加载的类路径下查找并加载第一个同名文件，带星号的classpath会在classpath路径中查找并加载所有的同名文件(按照下面案例的说法，虽然加载了所有同名文件，但是似乎并不是所有都会生效，部分会被覆盖掉；有待证实;还有可能是Maven存在资源过滤的问题,以后碰到了再回来翻博客)</li></ol><ul><li>贴个博客: <a href="https://www.cnblogs.com/mumu122GIS/p/10161725.html" target="_blank" rel="noopener">https://www.cnblogs.com/mumu122GIS/p/10161725.html</a></li><li>贴个博客: <a href="https://www.cnblogs.com/chenmingjun/p/10264644.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenmingjun/p/10264644.html</a></li><li>贴个案例: <a href="https://www.jianshu.com/p/5263e3a6cde2" target="_blank" rel="noopener">https://www.jianshu.com/p/5263e3a6cde2</a></li></ul><ol start="4"><li>使用tomcat测试SpringMVC流程时始终网页报404,排查发现lib文件放在了class文件夹下面，正确位置lib应该放在WEB-INF文件夹下，然后 再导入jar包，重新启动tomcat</li><li>测试SpringMVC流程(XML+接口版): </li></ol><ul><li>启动tomcat，解析web.xml,发现了<code>DispatcherServlet</code>，其配置文件的位置由classpath指定，进入到classpath指定的位置解析<code>springmvc-servlet.xml</code>配置文件</li><li><code>springmvc-servlet.xml</code>配置文件中有处理器映射器，处理器适配器和视图解析器，再有一个bean绑定实现了<code>Controller接口</code>的类，这个类实现了<code>Controller接口</code>的<code>ModelAndView</code>方法; 注意这个bean中的id名字前后有加<code>/</code>,这相当于<code>url-pattern</code></li><li><code>springmvc-servlet.xml</code>配置文件解析完成后，进入Controller中执行代码，返回测试信息，成功完成</li><li><img src="/img/blogpic/springmvc.jpg" alt="avatar"></li><li>过程中还有些关于文件目录的配置</li><li>这行留给以后填坑</li></ul><ol start="6"><li>注解版: <img src="/img/blogpic/anno.jpg" alt="avatar"><br><img src="/img/blogpic/controller.jpg" alt="avatar"></li><li>RESTful是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义</li></ol><ul><li>贴个博客: <a href="https://www.jianshu.com/p/ee92c9accedd" target="_blank" rel="noopener">https://www.jianshu.com/p/ee92c9accedd</a></li><li>贴个博客: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li><li>针对这类情况有专门的<code>@PostMapping</code>或<code>@GetMapping</code>等等这类的组合起来的注解</li><li>貌似RESTful没有完全统一的标准，只有宏观上的定义</li></ul><ol start="8"><li>不用视图解析器可以直接<code>return forward:...</code>,<code>return ...</code>,<code>return redirect:...</code></li><li>关于<code>return redirect:...</code>和<code>return forward:...</code>这两个方法都不受视图解析器的影响，不管视图解析器存在与否，都不会影响；重定向相当于拼接地址直接访问，所以对于WEB-INF下面的文件不能访问；而转发则可以访问WEB-INF下面的文件</li><li>当需要在URL地址栏传递对象参数时，地址栏的参数名字要和对象中的参数名字相同</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Web笔记</title>
    <link href="/2020/03/02/Web%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/02/Web%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>HTTP(超文本传输协议): 基于<code>TCP/IP</code>，默认端口号80，无状态(同一个连接中，两次成功请求间没有联系)</li></ol><ul><li>HTTP不需要传输层是面向连接的，只需要它是可靠的，由于<code>UDP</code>不可靠，<code>TCP</code>可靠，所以HTTP的传输层协议是<code>TCP/IP</code></li><li>HTTP/1.0默认为每一次请求/响应都打开单独的TCP连接</li><li>HTTP/1.1引入流水线和持久连接的概念，通过Connection头部来被控制，并且具有协议升级机制</li><li>HTTP/2是二进制协议，其HTTP报文被封装在帧中，一般使用HTTP/2来替代HTTP/1.1中的流水线功能</li></ul><ol start="2"><li>HTTP安全策略:</li></ol><ul><li>内容安全策略(CSP)</li><li>HTTP公钥锁定(HPKP)</li><li>HTTP严格传输安全(HSTS)</li><li>还有部分其他的安全策略</li></ul><ol start="3"><li>HTTP的跨域资源共享(CORS): 使用额外的HTTP头告诉浏览器来允许运行在一个域上的Web应用访问来自不同源服务器上的资源；<br>当一个资源从与该资源本身所在的服务器<strong>不同的域</strong>、<strong>协议</strong>或<strong>端口</strong>请求一个资源时，资源会发起一个跨域 HTTP 请求。</li><li>HTTP缓存:</li></ol><ul><li>对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。</li><li>通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。</li><li>如果max-age和expires属性都没有，就找头里的Last-Modified信息。若有，缓存的寿命就等于头里面Date的值减去Last-Modified的值乘以10%<br><code>缓存失效时间计算公式如下: expirationTime = responseTime + freshnessLifetime - currentAge；式中，responseTime表示浏览器接收到此响应的那个时间点。</code></li></ul><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="5"><li>URL重定向: 客户端发起请求给服务器端，当servlet方法执行到重定向时，则反馈给客户端这个响应，客户端根据这个响应再访问新的网址，两次不同地址的请求相互独立。<br>URL转发:客户端发起请求给服务器，当servlet方法执行到转发时，则仍然在服务器端执行转发请求，这种情况下的整个流程都是在一个request完成的；另外转发还分为显示转发和隐式转发。</li></ol><ul><li>以上对比都是基于Servlet中的<code>request.getRequestDispatcher(&quot;...&quot;).forword(request, response)</code>;和<code>response.sendRedirect(&quot;...&quot;)</code></li><li>重定向和转发之间的区别除了性能还有对网站权重的影响，水平不够，只做记载，水平够了再深入学习</li><li>贴个关于重定向和转发博客地址: <a href="https://www.cnblogs.com/yanggb/p/11825019.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanggb/p/11825019.html</a></li></ul><ol start="6"><li>Cookie: 服务器发送到用户浏览器并保存在本地的一小块数据，在下次浏览器向同一服务器发起请求时被携带发送到服务器，保持用户状态；Cookie大小有限制，Cookie数量有限制；由于Cookie会引起额外的性能开销，有新的浏览器API已经允许开发者直接将数据存储在本地</li><li>Session: 服务器端Cookie</li></ol><ul><li>贴个关于Cookie和Session的博客: <a href="https://www.iteye.com/blog/justsee-1570652" target="_blank" rel="noopener">https://www.iteye.com/blog/justsee-1570652</a></li><li>再贴个关于Session的博客: <a href="https://blog.csdn.net/weixin_42217767/article/details/92760353" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42217767/article/details/92760353</a></li></ul><ol start="8"><li>多用途互联网邮件扩展类型(MIME): 描述消息内容类型的因特网标准；当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>AJAX+JSON笔记</title>
    <link href="/2020/03/02/AJAX+JSON%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/02/AJAX+JSON%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>AJAX定义: <a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/ajax/index.asp</a></li><li>有更好的笔记就不写了自己的笔记了</li></ol><ul><li>贴个博客链接: <a href="https://segmentfault.com/a/1190000004322487#articleHeader0" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004322487#articleHeader0</a></li><li>贴个教程链接: <a href="https://www.w3school.com.cn/xmldom/dom_http.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xmldom/dom_http.asp</a></li></ul><ol start="3"><li>JSON: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON</a></li></ol><ul><li>记录: <a href="http://www.json.org.cn/resource/index.htm" target="_blank" rel="noopener">http://www.json.org.cn/resource/index.htm</a></li></ul><p>PS: 以上部分文章等以后水平够了再回来重读填坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记</title>
    <link href="/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/29/MySQL%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><p>MySQL是关系型数据库的一种，另外还有非关系型数据库</p></li><li><p>命令行操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 密码 --注意区分p的大小写，大小写p分别表示端口和密码&lt;br&#x2F;&gt;</span><br><span class="line">update mysql.user set authentication_string&#x3D;password(&#39;密码&#39;)where user&#x3D;&#39;root&#39; and Host&#x3D;&#39;Localhost&#39;;--修改用户密码</span><br><span class="line">flush privileges; --刷新权限</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line">show databases; -- 查看所有的数据库</span><br><span class="line"></span><br><span class="line">exit；</span><br></pre></td></tr></table></figure><p>PS: 敲完代码敲回车，在第二行输入<code>;</code>再敲回车命令结果就会回显，或者直接语句后面加<code>;</code>再敲回车同样会回显<br>PS: 剩下的懒得写了，命令行语句百度查询</p></li><li><p>MySQL语句: 中括号代表可选操作</p><blockquote><p><code>CREATE DATABASE [IF NOT EXISTS] yuexinbaiwan      --创建数据库</code><br><code>DROP DATABASE IF EXISTS yuexinbaiwan      --删除数据库</code></p></blockquote></li><li><p>MySQL引擎: InnoDB和MyISAM</p></li><li><p>修改表名: <code>ALTER TABLE 原表名 RENAME AS 目标表名</code><br>修改约束: <code>ALTER TABLE 表名 MODIFY 字段名 VARCHAR(11)</code><br>修改字段名: <code>ALTER TABLE 表名 CHANGE 原字段名 目标字段名 INT(1)</code><br>增加表字段: <code>ALTER TABLE 表名 ADD 字段名 INT(11)</code><br>删除表字段: <code>ALTER TABLE 表名 DROP 字段名</code><br>删除表: <code>DROP TABLE IF EXISTS 表名</code><br>注: 大小写不敏感</p></li><li><p>外键: 减少使用外键和级联可以简化开发和测试</p></li><li><p>修改具体数据: <code>UPDATA 表名 SET 字段名=&quot;...&quot; where 约束条件</code>(修改数据必须加约束条件，不然会默认修改该字段所有数据)<br><code>PS: 使用时再查找相关文档细化知识</code></p></li><li><p>删除具体数据: <code>DELETE FROM 表名 [where 约束条件]</code><br>清空表: <code>TRUNCATE 表名</code></p></li></ol><ul><li><code>DELETE</code>和<code>TRUNCATE</code>的异同点: 两者都删除数据，但不会删除表结构，不同的是使用<code>TRUNCATE</code>不影响事物，且重新设置自增列，计数器归零<br>而<code>DELETE</code>不会影响自增量</li><li>补充: 自增量在InnoDB中是存在内存中，断电即失；而在MyISAM则继续从上一个自增量开始，存在文件中，不会断电即失</li></ul><ol start="9"><li>查询+别名: <code>SELECT 字段名 AS 别名,字段名 AS 别名  FROM  表名</code>(表名也可以加别名)<br>查询+拼接: <code>SELECT CONTACT(&#39;需要拼接的数据&#39;,字段名) AS 别名 FROM 表名</code><br>查询+去重: <code>SELECT DISTINCT 字段名 FROM 表名</code><br><code>PS: 还有许多，具体查阅文档</code></li><li>MySQL运算符: 算术运算符，比较运算符，逻辑运算符，位运算符</li><li>在模糊查询中注意<code>%</code>和<code>_</code>的区别</li><li>联表查询的七种join理论: <img src="/img/blogpic/join.jpg" alt="avatar"></li><li>自连接+联表查询</li><li>查询结果排序: <code>ORDER BY [ASC|DSC]</code>(升序|降序)</li><li>查询结果分页: <code>LIMIT 6,5 //检索记录7-11行</code>或者<code>LIMIT 5 //检索记录前5行，相当于LIMIT 0,5</code>,<br>即<code>LIMIT 起始值 [,检索数目]</code>(LIMIT中计数默认从0开始；即第0行，第1行)</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="16"><li>MySQL也有函数，例如第九条中的CONTACT(): 可查询文档或菜鸟教程</li><li><code>coalesce(name, &#39;总数&#39;)</code>和<code>WITH ROLLUP</code></li><li>MD5加密: <code>UPDATE 表名 SET pwd=MD5(pwd) where 约束条件</code>或者插入时加密: <code>INSERT INTO 表名 VALUES(...,...,MD5(...))</code></li><li>事物(满足ACID原则): <code>SAVEPOINT(保存点)</code>  <code>RELEASE SAVEPOINT</code>  <code>ROLLBACK TO SAVEPOINT</code></li><li>索引: 在数据量庞大的时候能极大的优化性能:<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li></ol><ul><li>博客读后感: 基础设施决定上层建筑，要学习的东西还有很多很多</li><li><code>EXPLAIN SELECT</code>(相比<code>SELECT</code>会显示一些特别的信息)</li></ul><ol start="21"><li>数据库备份</li><li>使用Java中的<code>PreparedStatement</code>防止SQL注入</li><li>关系型数据库范式: 第一范式要求每一列中的信息都不可分割，第二范式要求每一列都与所有主键完全依赖(或者说相关)，第三范式要求每一列信息直接依赖，不能间接相关(例如A -&gt; B,B -&gt; C；那么A和B在一张表，B和C则应放在另一张表)<br>PS: 上文中的(依赖)可以换成(相关)，这样更通俗；上文的总结完全依赖于下面两个链接中的精华，第一个链接精炼，第二个链接通俗<br><a href="https://www.jianshu.com/p/08d123026438" target="_blank" rel="noopener">https://www.jianshu.com/p/08d123026438</a><br><a href="https://www.cnblogs.com/wsg25/p/9615100.html" target="_blank" rel="noopener">https://www.cnblogs.com/wsg25/p/9615100.html</a></li><li>数据库连接池</li></ol><p>PS: 了解的东西多了，才发现还要学习的东西更多</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring笔记</title>
    <link href="/2020/02/27/Spring%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/27/Spring%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li>Spring是非入侵式框架，基于Interface21框架；IOC+AOP+事物处理</li><li>控制反转(IOC): 对象的创建与对象间的依赖关系完全硬编码在程序中并由程序自己控制，而控制反转则将控制权转移给第三方； 可以利用依赖注入(DI)实现</li><li>有XML和注解两种实现IOC</li><li>XML:</li></ol><ul><li>使用Spring来创建对象，在Spring中都称为bean</li><li>在bean中来实现对象的属性赋值</li><li>这种情况下，程序不用new对象，只需要被动接受Spring容器创建好的对象</li><li>一句话: 对象由Spring创建，管理，装配</li></ul><ol start="5"><li>接上:</li></ol><ul><li>bean中的property基本类型用value，引用类型用ref;其中property必须搭配Set方法使用</li><li>property的name是xxx,则方法为setXxx,例如property的name=”te”,那么对应类中需要setTe(Object ob)方法,命名规范严格遵照驼峰规则</li></ul><ol start="6"><li>IOC对象创建</li></ol><ul><li>无参构造函数</li><li>有参构造函数: 可以使用多种方式在配置文件中赋值没具体查阅Spring文档</li></ul><ol start="7"><li>当使用<code>ClassPathXMLApplication(&quot;bean.xml&quot;)</code>即配置文件加载后，只要beans.xml中配置了bean,即使没有调用，也会创建对象，可以使用无参构造函数测试这种情况，且一个beans在容器中只创建了一个</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="8"><li>使用别名标签给同一个类可以取多个名字，还可以直接在bean中使用name取别名，同一个name中取多个别名可以用逗号或空格分割</li><li>在XML配置文件中可以用<code>import</code>标签导入其他配置文件</li><li>多种不同类的属性的具体注入方式看Spring官方文档</li><li>namespace: 命名空间，防止命名冲突；一般有统一的命名格式</li></ol><ul><li>Spring中有P命名空间，<code>&lt;p:name=&quot;...&quot;&gt;&lt;/p&gt;</code>给属性赋值</li><li>Spring中有C命名空间,给有参构造器赋值</li><li>使用需要导入约束</li></ul><ol start="12"><li>bean作用域:</li></ol><ul><li>单例模式: Spring默认机制</li><li>原型模式: 每次从容器中get时，都会产生一个新引用</li><li>还有部分作用域涉及到Web</li></ul><ol start="13"><li>自动装配:</li></ol><ul><li><code>autowire=&quot;byName&quot;</code>,byName是自动在容器中查找，根据set方法后的名字来装配，遵循驼峰命名规则</li><li>除了<code>byName</code>还有<code>byType</code>等等，<code>byType</code>要求同类(bean)唯一,默认<code>byType</code></li></ul><ol start="14"><li>XML配置实现的功能，同样也能使用注解实现，注解要求JDK1.5和Spring2.5</li></ol><ul><li>注解同样需要导入约束</li><li>使用<code>@Autowired</code>可以省略掉set方法,包含<code>@Autowired</code>的类文件同样要在bean中配置</li><li>同一个类有多个bean时，<code>@Autowired</code>需要搭配<code>@Qualifier</code>使用<code>@Qualifier(value=&quot;&quot;)</code>选取特定的bean的id</li><li>Java中有个<code>@Resource(name=&quot;&quot;)</code>，name可以不写，类似<code>@Autowired + @Qualifier(value=&quot;&quot;)</code>的功能</li></ul><ol start="15"><li><code>&lt;context:component-scan base-package=&quot;包名1 包名2...&quot;/&gt;</code>扫描指定包，搭配写在项目中的<code>@Component</code>使用；把普通pojo实例化到spring容器中:</li></ol><ul><li>对上面的解释: 写了<code>@Component</code>的类就相当于在配置文件中写了bean，bean的id默认为类的小写名字(实际上配置文件中没有显式写出这个类的bean)</li><li>使用<code>@Value(&quot;&quot;)</code>给属性赋值</li></ul><ol start="16"><li><code>@Configuration</code>方式也可以配置bean,结合<code>@component(&quot;完全版类名&quot;)</code>指定类文件，在需要的方法前一行<code>@Bean</code>，在使用时使用<code>AnnotationConfigApplicationContext(参数)</code>，然后<code>getBean(&quot;方法名&quot;)</code>； 与XML配置的操作类似</li><li>代理模式: 可以在不修改原有代码的基础上对某些功能进行增加</li><li>面向切面(AOP): Spring版动态代理</li><li>AOP实现: 先导入实现AOP的jar包，再将自己写的增强版的类用bean注入容器</li></ol><ul><li>配置文件版: <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- excution是一个表达式，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:poincut</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">excution</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--切入点设置好，再设置切入位置，具体查Spring文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>以上非完全版，具体以Spring文档为准，暂时不细查，等到项目实战中再细化</p><ul><li>注解版: <code>@Aspect</code>,<code>@Before</code>等等，同样需要在配置文件中配置，具体查Spring，大概在Spring文档的5.4节中</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片问题</title>
    <link href="/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/27/%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今日问题</p><h2 id="外链图片加载失败"><a href="#外链图片加载失败" class="headerlink" title="外链图片加载失败"></a>外链图片加载失败</h2><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><ol><li>可能是由于服务器检测到请求头中的refer不是自家域名，为了减轻服务器压力，拦截访问</li></ol><ul><li>学习资料: <a href="https://blog.csdn.net/qq_42248939/article/details/97377126" target="_blank" rel="noopener">https://blog.csdn.net/qq_42248939/article/details/97377126</a></li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>下载到本地访问</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java笔记</title>
    <link href="/2020/02/26/Java%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/02/26/Java%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Java新手上路，谨以此记录自己的第一个博客笔记</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><ol><li><code>Public</code>类的名字与文件名一致</li><li>类的构造器(默认存在且其权限修饰符与所属类一致，也可以自己编写)，父类构造器不能被子类继承</li><li>可变个数的参数: 如<code>public void test (String...args){}</code></li><li>四种访问权限修饰符: private(类内部使用),default(类内部+包）,protected(类内部+包+子类),public(任何地方)</li></ol><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><ol start="5"><li>关键字this: 当前正在引用的对象或者当前正在初始化的对象，<code>this(.....)</code>可用来调用构造器<br>要求:</li></ol><ul><li>必须存在未使用<code>this()</code>调用的构造器  </li><li><code>this()</code>调用要放在首行。若本类没有则在父类查找</li></ul><ol start="6"><li>JavaBean: 拥有Set和Get方法的公共类且属性私有，一种可重用组件</li><li>类的继承只能有一个父类(单继承)，若对继承类方法重写，权限限定不能比原方法严格（如原方法是protected,重写后的方法就是public或者protected而不能是private）</li></ol><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><ol start="8"><li><code>Super</code>用于调用父类中的指定操作，不局限于直接父类，还可以对多层继承父类调用，且Super调用写在第一行</li><li>子类要调用父类构造器，默认调用父类无参构造器。若父类没有无参构造器，则需要手动调用其他构造函数</li><li><code>Super</code>和<code>this</code>调用构造器只能使用其中一个，因为两者都要求占据第一行</li><li>子对象实例化过程:</li></ol><ul><li>先加载父类字节码，在加载子类字节码. </li><li>在堆内存中开辟空间并分配地址，默认初始化. </li><li>子类构造函数进栈，显式初始化父类属性. </li><li>父类构造方法进栈，执行完后父类构造方法出栈</li><li>显式初始化子类属性，返回引用地址给变量，子类构造方法出栈.</li></ul><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><ol start="12"><li>多态存在的三个必要条件: 继承，重写，父类引用指向子类对象(例如: student继承person类，student中重写了person的show方法，{person e = new student();e.show()动态绑定，最终输出的是子类student中的show})。方法形参为父类，可以传参时传入子类，调用参数的方法时会用到多态</li><li>Instanceof操作符: <code>x instanceof A</code>:检验对象x是否是类A的对象，返回值为boolean(若x instanceof A为true,x instanceof A的父类,也为true)</li><li>==: 基本类型比较是值等则为true，引用类型比较则是指向同一个对象才返回true；equals()当比较例如String类是比较String的值相同则为true，而不是比较是否指向同一个对象</li><li>包装类: <code>boolean b=new Boolean(“true”)</code>这是自动拆箱，<code>Boolean b=true</code>这是自动装箱，都是在JDK1.5后支持。包装类方便基本类型与字符串的转换</li><li><code>System.out.println(x)//若X是对象</code>，则相当于输出<code>x.toString()</code>.</li><li>用static修饰的方法和变量可以直接用(类名.方法)调用，随着类的加载而加载，被所有对象共享</li><li>单例模式: 用static创建变量，进行一次实例化，共同使用，分为1.饿汉式 2.懒汉式(两者区别，饿汉式在类实例化时就创建，懒汉式在调用<code>getInstance()</code>方法时才创建)</li><li>代码块先于构造器初始化,静态代码块值执行一次</li><li>匿名内部类用于隐式继承父类或实现接口，可以在匿名内部类中用代码块初始化</li><li><code>final</code>修饰的类不能被继承，<code>final</code>修饰的变量不能被修改且必须显示赋值，<code>final</code>饰的方法不能被子类重写</li></ol><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><ol start="22"><li>Abstract修饰抽象方法和抽象类，抽象类不能实例化，但可以拥有构造器，继承抽象类的子类必须重写抽象类中的抽象方法，抽象方法是只有声明没有实现。若某类中有抽象方法，则该类必须声明为抽象类</li><li>模板设计模式: 定义一个抽象类，子类继承抽象类，可以直接使用而不用重写部分已经写好的通用方法。</li><li>接口与抽象类的区别:</li></ol><ul><li>接口中（默认<code>public abstract</code>） 只能声明方法而不能实现方法2.接口中的变量只能是<code>public static final</code>类型的</li><li>接口不能含有静态代码块、静态方法以及构造器 4.一个类只能继承一个抽象类，但是却可以实现多个接口</li></ul><ol start="25"><li>工厂模式:</li></ol><ul><li>定义接口，将实现同一接口的不同类放入工厂，并延迟到子类再决定实例化哪一个类。  </li></ul><ol start="26"><li>内部类也是类，但特殊点在若内部类是<code>static</code>修饰，就不能使用外部类的非static的成员变量。而非static的内部类中的成员不能声明为static（内部类主要用来解决JAVA不能多层继承的问题）</li><li>异常问题，子类不能抛出比父类更大范围的异常</li><li>Java分为三大集合:</li></ol><ul><li>Set,Map,List</li><li><code>set和list</code>使用<code>iterator</code>或者foreach迭代</li></ul><ol start="29"><li><code>treeSet</code>有序，<code>treeMap</code>有序</li><li>Map使用keySet或者entrySet遍历</li><li>Collections工具</li></ol><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><ol start="32"><li>泛型:</li></ol><ul><li>泛型类；</li><li>泛型接口: 实现泛型接口时如果不具体指定类型，则实现类也需要加上泛型（例如<code>class A&lt;T&gt; implements interface&lt;T&gt;</code>）；</li><li>泛型方法: <code>public &lt;T&gt; void test(T t){}</code>在静态方法中不能使用类定义泛型，若需要使用，只能使用静态方法自己定义的泛型<code>public static &lt;T&gt; void test(T t){}</code></li></ul><ol start="33"><li>通配符是“？”:</li></ol><ul><li><code>&lt;? extends Person&gt;</code>表示通配只接受Person及其子类的引用</li><li><code>&lt;? super Person&gt;</code>表示通配只接受Person及其父类的引用</li><li><code>&lt;？Extends Comparable&gt;</code>表示通配只接受实现<code>Comparable接口</code>的类的引用</li></ul><ol start="34"><li>枚举类:<br><code>Season summer = Season.SUMMER;Summer.showInfo();</code><br>每个枚举都是单例模式</li><li>注解: 编写注解需要使用@interface声明，在注解前面也需要加其他注解来限制编写的注解的作用范围</li><li>文件流: File类: 其中，<code>File.separator</code>为当前系统分隔符，File只能操作文件本身，比如删除文件，但不能改变文件的内容</li><li>文件流: <code>FileOutputStream</code>输出流（字节流），将数据输出到某文件，<code>FileInputStream</code>输入流（字节流），从某文件中获取数据输入（可用byte数组存储）。<code>FileReader</code>输入流（字符流，可以char数组存储）</li><li>缓冲流: 先将数据放入内存中，再在内存中操作数据，提升性能。<code>BufferedInputStream</code>和<code>BufferedOutputStream</code></li><li>转换流: <code>InputStreamReader</code>等等。。不同文本格式的转换，比如GBK到UTB-8</li><li>标准输入输出流</li><li>对象流: 序列化和反序列化（包名，类名等要完全一致）</li><li>反射机制: 前提是JVM已经加载过这个类</li></ol><ul><li>反射机制中的Class代表该字节码文件，Class类是JVM创建的表示类信息的类，而Object是所有类的父类，可以利用<code>Class.class.isAssignableFrom(Object.class)</code>来判断子类父类关系</li><li>贴个博客：<a href="https://blog.csdn.net/u014704496/article/details/41316827" target="_blank" rel="noopener">https://blog.csdn.net/u014704496/article/details/41316827</a></li><li>可以利用反射机制调用类的私有方法和私有变量（这类操作会破坏类的封装性）</li></ul><ol start="43"><li>Java动态代理: 当需要修改方法执行前或执行后的操作时，利用动态代理可以简化操作，想要通过<code>Proxy.newProxyInstance</code>方法被代理则此对象的类需要实现接口<br>JDK实现:</li></ol><ul><li>自己定义的接口 </li><li>实现这个接口 </li><li>实现<code>InvocationHandler</code>接口</li><li>利用第三步中的类获取代理类，调用方法（JVM会自动生成Proxy类文件，调用InvocationHandler接口中实现Invoke方法达到最终目的）</li></ul><ol start="44"><li>Java静态代理和动态代理讲解:</li></ol><ul><li><a href="https://www.jianshu.com/p/9bcac608c714" target="_blank" rel="noopener">https://www.jianshu.com/p/9bcac608c714</a></li><li><a href="https://www.bilibili.com/video/av63885236" target="_blank" rel="noopener">https://www.bilibili.com/video/av63885236</a></li></ul><ol start="45"><li>创建线程:</li></ol><ul><li>继承<code>thread</code>类  </li><li>实现<code>Runnable</code>接口</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的博客</title>
    <link href="/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/02/25/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>博客测试</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/02/25/hello-world/"/>
    <url>/2020/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
